<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker</title>
      <link href="2020/12/03/Docker/Docker/"/>
      <url>2020/12/03/Docker/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>原作者:  小陈    微信: chenxu521600</p><p>纯手打, 有修改</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><img src="Dovker.assets/image-20200903092232148.png" class="lazyload" data-srcset="Dovker.assets/image-20200903092232148.png" srcset="data:image/png;base64,666" alt="image-20200903092232148"></p><p>官网的介绍是” Docker is the world‘s leading software container platform “官方给docker的定位是一个应用容器平台.</p><h2 id="为什么是Docker"><a href="#为什么是Docker" class="headerlink" title="为什么是Docker"></a>为什么是Docker</h2><h2 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h2><p><img src="Docker.assets/image-20200903094505690.png" class="lazyload" data-srcset="Docker.assets/image-20200903094505690.png" srcset="data:image/png;base64,666" alt="image-20200903094505690"></p><h2 id="Docker的核心"><a href="#Docker的核心" class="headerlink" title="Docker的核心"></a>Docker的核心</h2><p><img src="Docker.assets/image-20200903151713477.png" class="lazyload" data-srcset="Docker.assets/image-20200903151713477.png" srcset="data:image/png;base64,666" alt="image-20200903151713477"></p><ul><li>镜像：一个镜像代表一个应用环境，它是一个只读的文件，如mysql镜像，tomcat镜像…</li><li>容器：镜像每次运行之后就是产生一个容器，就是正在运行的镜像，特点是可读可写</li><li>仓库：用来存放镜像的位置，蕾仕于maven仓库，也就是镜像下载和上传的位置</li><li>dockerfile：docker生成的镜像配置文件，用来书写自定义镜像的一些配置</li><li>tar：一个对镜像打包的文件，ihou还可以还原成镜像</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="2020/12/03/Docker/Docker%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/03/Docker/Docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><blockquote><p>来源：维基百科，自由的百科全书</p></blockquote><table><thead><tr><th align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/250px-Docker_%28container_engine%29_logo.svg.png" class="lazyload" data-srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/250px-Docker_%28container_engine%29_logo.svg.png" srcset="data:image/png;base64,666"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">原作者</a></td><td align="center">Solomon Hykes</td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC">开发者</a></td><td align="center">Docker, Inc.</td></tr><tr><td align="center">初始版本</td><td align="center">2013年3月13日</td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E4%BB%93%E5%BA%93_(%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)">源代码库</a></td><td align="center"><a href="https://github.com/docker/docker-ce">github.com/docker/docker-ce</a><a href="https://www.wikidata.org/wiki/Q15206305#P1324"><img src=".static/Docker%E6%A6%82%E8%BF%B0-img/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png" class="lazyload" data-srcset=".static/Docker%E6%A6%82%E8%BF%B0-img/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png" srcset="data:image/png;base64,666" alt="编辑维基数据链接"></a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Go">Go</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Linux">Linux</a>、<a href="https://zh.wikipedia.org/wiki/Windows">Windows</a>、<a href="https://zh.wikipedia.org/wiki/MacOS">macOS</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%B9%B3%E5%8F%B0">系统平台</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>、<a href="https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B">ARM</a>、s390x、<a href="https://zh.wikipedia.org/wiki/Ppc64">ppc64le</a></td></tr><tr><td align="center">类型</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96">操作系统层虚拟化</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81">许可协议</a></td><td align="center"><strong>可执行档：</strong><a href="https://zh.wikipedia.org/wiki/%E5%85%8D%E8%B2%BB%E5%A2%9E%E5%80%BC">免费增值</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1">软件即服务</a> <strong>源代码：</strong><a href="https://zh.wikipedia.org/wiki/Apache%E8%AE%B8%E5%8F%AF%E8%AF%81">Apache许可证</a> 2.0</td></tr><tr><td align="center">网站</td><td align="center"><a href="https://www.docker.com/">www.docker.com</a></td></tr></tbody></table><p><strong>Docker</strong> 是一个<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC">开放源代码</a><a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>，是一个<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%B9%B3%E8%87%BA">开放平台</a>，用于开发应用、交付（shipping）应用、运行应用。 Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件地速度。[<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-1">1]</a></p><p><strong>Docker容器</strong> 与虚拟机类似，但原理上，容器是将<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96">操作系统层虚拟化</a>，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。[<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-2">2]</a></p><p><strong>Docker</strong> 利用<a href="https://zh.wikipedia.org/wiki/Linux%E6%A0%B8%E5%BF%83">Linux核心</a>中的资源分离机制，例如<a href="https://zh.wikipedia.org/wiki/Cgroups">cgroups</a>，以及Linux核心<a href="https://zh.wikipedia.org/w/index.php?title=Linux%E5%91%BD%E5%90%8D%E7%A9%BA%E9%96%93&action=edit&redlink=1">名字空间</a>（namespaces），来创建独立的<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96">容器</a>（containers）。这可以在单一Linux实体下运作，避免引导一个<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E6%A9%9F%E5%99%A8">虚拟机</a>造成的额外负担[<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-3">3]</a>。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">网络</a>、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括<a href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94">存储器</a>、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由<a href="https://zh.wikipedia.org/wiki/Libvirt">libvirt</a>的<a href="https://zh.wikipedia.org/wiki/LXC">LXC</a>与systemd - nspawn提供界面的基础上，开始包括libcontainer库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施，</p><p>依据行业分析公司“451研究”：“Dockers是有能力打包应用程序及其虚拟容器，可以在任何Linux服务器上运行的依赖性工具，这有助于实现灵活性和便携性，应用程序在任何地方都可以运行，无论是<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E7%94%A8%E9%9B%B2">公用云</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A7%81%E6%9C%89%E9%9B%B2">私有云</a>、单机等。” [<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-4">4]</a>。</p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><h2 id="通过安装脚本-推荐"><a href="#通过安装脚本-推荐" class="headerlink" title="通过安装脚本 - 推荐"></a>通过安装脚本 - 推荐</h2><ul><li><p>CentOS</p><p>  Docker 仅支持以下的 64 位 CentOS 版本：</p><ul><li><p>CentOS 7</p></li><li><p>CentOS 8</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 使用官方安装脚本安装curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun# 使用国内 daocloud 一键安装命令curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>TODO: 待更新</p><h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><blockquote><p>如果使用dockers的</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a>辅助命令</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker --version# 版本信息&#x3D; docker -vdocker info# 详细信息docker --help# 帮助<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="images-镜像命令"><a href="#images-镜像命令" class="headerlink" title="images 镜像命令"></a>images 镜像命令</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看本机中所有镜像docker images# 列出本地所有镜像-a# 列出所有镜像(包含中间映像层)-q# 只显示镜像id# 搜索镜像docker search [options] 镜像名# 去dockerhub上查询镜像-s 指定值# 列出收场数不少于指定值的镜像--no-trunc  # 显示完整镜像信息# 从仓库下载镜像docker pull 镜像名[:TAG|@DIGEST]# 下载镜像# 删除镜像docker rmi 镜像名# 删除镜像-f# 强制删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Contrainer-容器命令"><a href="#Contrainer-容器命令" class="headerlink" title="Contrainer 容器命令"></a>Contrainer 容器命令</h2><h3 id="基本命令-容器外操作"><a href="#基本命令-容器外操作" class="headerlink" title="基本命令(容器外操作)"></a>基本命令(容器外操作)</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 运行容器docker run 镜像名# 镜像名新建并启动容器--name# 别名 为容器起一个名字-d# 启动守护式容器(在后台启动容器)-p# 映射端口号:原始端口号例:# 查看运行的容器docker ps# 列出所有正在运行的容器-a# 正在运行的和历史运行过的容器-q# 静默模式, 只显示容器id# 停止|关闭|重启容器docker start 容器名或id# 开启容器docker restart 容器名或id# 重启容器docker stop 容器名或id# 停止容器docker kill 容器名或id# 关闭容器# 删除容器docker rm -f 容器名或id例docker rm -f $(docker ps -aq)# 删除所有容器# 查看容器内进程docker top 容器名或id# 查看容器内进程# 产看容器内部细节docker inspect 容器id# 产看容器内部细节# 查看容器的运行日志docker logs [options] 容器名或id# 查看容器的运行日志-t# 加入时间戳-f# 跟随最新的日志打印<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进阶命令-容器内操作"><a href="#进阶命令-容器内操作" class="headerlink" title="进阶命令(容器内操作)"></a>进阶命令(容器内操作)</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入容器内部docker exec [options] 容器id 容器内命令# 进入容器内执行命令-i# 以交互模式运行容器,通常与-t一起使用-t# 分配一个伪终端# 容器内安装软件apt-get updateapt-get install 安装包名称# 修改容器内文件# 退出容器exit# 退出容器# 将容器打包为性的镜像docker commit -a&#x3D;&quot;作者&quot; -m&#x3D;&quot;描述信息&quot; 容器id 目标镜像名称:TAG# 从容器中复制文件到宿主机目录中 docker cp 容器id:容器内资源路径 宿主机目录路径# 将容器内资源拷贝到宿主机上# 容器目录与宿主机目录同步 (数据卷 必须在运行容器时进行设置)docker run -it -v &#x2F;宿主机目录:&#x2F;容器目录:ro(只读) 镜像名注: 宿主机目录必须是绝对目录,宿主机目录会覆盖容器目录内容    运行 docker inspect 容器id 检查json串里有没有如下内容, 有则证明挂载成功    &quot;Mounts&quot;:&#123;    &#123;    &quot;Type&quot;:&quot;bind&quot;,    &quot;source&quot;:&quot;宿主机目录&quot;,    &quot;Destination&quot;:&quot;容器目录&quot;,    &quot;Mode&quot;:&quot;&quot;,    &quot;RW&quot;:true,    &quot;Propagation&quot;:&quot;rprivate&quot;,    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Docker-file"><a href="#Docker-file" class="headerlink" title="Docker file"></a>Docker file</h1><blockquote><p>​    DockerFile可以认为是**Docker镜像的描述文件, 是由一系列的命令和参数构成的 ‘脚本’ **</p><p>​    主要作用是<strong>用来构建docker镜像的构建文件</strong></p></blockquote><p><img src="https://s3.ax1x.com/2020/12/03/DoxWHH.png" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/03/DoxWHH.png" srcset="data:image/png;base64,666"></p><h2 id="Dockerfile解析过程"><a href="#Dockerfile解析过程" class="headerlink" title="Dockerfile解析过程"></a>Dockerfile解析过程</h2><p><img src="https://s3.ax1x.com/2020/12/03/DozFrF.png" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/03/DozFrF.png" srcset="data:image/png;base64,666"></p><h2 id="Dockerfile保留命令"><a href="#Dockerfile保留命令" class="headerlink" title="Dockerfile保留命令"></a>Dockerfile保留命令</h2><table><thead><tr><th>保留字</th><th align="center">作用</th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td align="center">当前镜像是基于哪个镜像的, 第一个指令必须是FROM</td></tr><tr><td><strong>RUN</strong></td><td align="center"><strong>构建镜像时需要运行的命令</strong></td></tr><tr><td><strong>MAINTAINER</strong></td><td align="center">镜像维护者的姓名和邮箱地址 (官方不再推荐使用 废弃)</td></tr><tr><td><strong>WORKDIR</strong></td><td align="center">指定咋创建容器后, 终端默认登录进来的工作目录, 一个落脚点</td></tr><tr><td><strong>ENV</strong></td><td align="center">用来在构建容器过程中设置环境变量</td></tr><tr><td><strong>ADD</strong></td><td align="center">将宿主机目录下的文件拷贝进镜像  且ADD命令会自动处理URL和解压tar包</td></tr><tr><td><strong>COPY</strong></td><td align="center">类似ADD  拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</td></tr><tr><td><strong>VOLUME</strong></td><td align="center">容器数据卷  用于数据保存和持久化操作</td></tr><tr><td><strong>CMD</strong></td><td align="center">指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD命令, 但只有最后一个生效, CMD会被docker run之后的参数替换</td></tr><tr><td><strong>ENTRYPOINT</strong></td><td align="center">指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样, 都是在指定容器启动程序及其参数</td></tr></tbody></table><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><blockquote><p>​    基于哪个镜像构建新的镜像, 在构建时会从dockerhub拉取base镜像, 必须作为Dockerfile的第一个指令出现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的一些小工具</title>
      <link href="2020/12/02/Linux/Linux%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
      <url>2020/12/02/Linux/Linux%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="screenfetch"><a href="#screenfetch" class="headerlink" title="screenfetch"></a>screenfetch</h2><ul><li><p>Ubuntu</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt install screenfetch<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>CentOS</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 先下载：wget -O screenfetch-dev https:&#x2F;&#x2F;git.io&#x2F;vaHfR# 然后丢到&#x2F;usr&#x2F;bin或类似的目录，如果在PATH就比较方便：sudo mv .&#x2F;screenfetch-dev &#x2F;usr&#x2F;bin&#x2F;screenfetch# 记得加上可执行权限：sudo chmod +x &#x2F;usr&#x2F;bin&#x2F;screenfetch# 此时应该可以使用了：screenfetch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器性能测试</title>
      <link href="2020/12/02/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>2020/12/02/Linux/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>性能测试，仅供参考/娱乐<br><a href="https://zhuanlan.zhihu.com/p/143894333">原文连接</a></p></blockquote><h1 id="综合性能测试"><a href="#综合性能测试" class="headerlink" title="综合性能测试"></a>综合性能测试</h1><p>输入下列命令，执行teddysun博主的脚本：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget -qO- bench.sh | bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s3.ax1x.com/2020/12/03/DT8Hzt.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/03/DT8Hzt.jpg" srcset="data:image/png;base64,666"></p><h1 id="UnixBench跑分"><a href="#UnixBench跑分" class="headerlink" title="UnixBench跑分"></a>UnixBench跑分</h1><p>虽然UnixBench跑分测试并不能完全代表真实性能，但还是可以提供一定的参考。执行以下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;soft.laozuo.org&#x2F;scripts&#x2F;UnixBench5.1.3.tgztar -zxvf UnixBench5.1.3.tgzcd UnixBenchmake.&#x2F;Run<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://i.loli.net/2020/12/03/qriyN4cIFVeozu8.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/12/03/qriyN4cIFVeozu8.jpg" srcset="data:image/png;base64,666" alt="Snipaste_2020-12-03_13-41-12.jpg"></p><h2 id="错误修复"><a href="#错误修复" class="headerlink" title="错误修复"></a>错误修复</h2><ul><li><p>-bash: ./Run: /usr/bin/perl: bad interpreter: No such file or directory</p><p>  修复方法:</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 以root权限执行以下命令wget -O &#x2F;usr&#x2F;bin&#x2F;prel https:&#x2F;&#x2F;github.com&#x2F;flathub&#x2F;io.github.Hexchat.Plugin.Perl&#x2F;blob&#x2F;master&#x2F;io.github.Hexchat.Plugin.Perl.json#L15-L47<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  修复成功</p></li></ul><h1 id="Speedtest带宽测试"><a href="#Speedtest带宽测试" class="headerlink" title="Speedtest带宽测试"></a>Speedtest带宽测试</h1><p>执行以下命令测速主机的上传和下载的带宽：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;raw.github.com&#x2F;sivel&#x2F;speedtest-cli&#x2F;master&#x2F;speedtest.pypython speedtest.py --share<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="PING测试"><a href="#PING测试" class="headerlink" title="PING测试"></a>PING测试</h1><p>使用<a href="http://ipip.net在线工具对主机的PING响应时间进行测试（北京时间晚上11点左右），结果如下：">http://ipip.net在线工具对主机的PING响应时间进行测试（北京时间晚上11点左右），结果如下：</a></p><p>使用mping脚本一键测试阿里轻量应用服务器实例到国内电信、联通、移动线路的回程Ping：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helloxz&#x2F;mping&#x2F;master&#x2F;mping.shbash mping.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>其中电信和联调的延迟较高，移动的延迟较低。</p><h1 id="路由测试"><a href="#路由测试" class="headerlink" title="路由测试"></a>路由测试</h1><ol start="5"><li>路由测试<br>去程路由测试<br>使用BestTrace工具，本地电脑使用广东电信网络，在北京时间晚上十点多测试到VPS主机的去程路由。</li></ol><p>需要绕日本NTT，有点惨。</p><p>第二次本地电脑使用北京联通网络进行去程路由测试：</p><p>同样需要绕日本NTT。。。</p><p>回程路由测试<br>再测试VPS主机到本地的回程路由测试，运行以下命令:</p><p>wget <a href="https://cdn.ipip.net/17mon/besttrace4linux.zip">https://cdn.ipip.net/17mon/besttrace4linux.zip</a><br>unzip besttrace*<br>chmod +x besttrace<br>./besttrace -q1 &lt;本地IP地址&gt;<br>第一次测试的本地环境使用广东电信网络：</p><p>第二次测试的本地环境使用北京联通网络：</p><p>回程测试结果也不是很理想。</p><ol start="6"><li>视频播放测试<br>选择在北京时间晚上10点～11点左右，对部分朋友比较关注的视频播放进行测试，发现选择360p的视频播放也比较卡顿，甚至有的时候干脆刷不出来。</li></ol><p>下面是播放360p视频的截图。</p><p>三、功能测试<br>以下是使用阿里云轻量应用服务器的具体功能的一些感受，有好的也有不好的，供大家参考。</p><p>提供使用应用镜像一键部署应用的功能，在操作系统之上封装了应用软件和运行环境，满足快速建站的需求。目前提供8种的应用镜像，数量不算多，包括：WordPress, LAMP, Node.js, ECShop, phpwind, ASP.NET, Drupal, BT-Panel。<br>应用部署完成之后，可以从控制台界面查看应用的详细信息以及操作步骤，这一点对用户比较友好。<br>有独立的公网IP，但暂时不支持IPv6网络。<br>提供一键绑定域名功能。<br>支持快照，支持挂载、卸载磁盘。<br>可以按使用时长退款，但是入口需要从计费界面进，如前所述。<br>四、综合评价<br>价格相比海外VPS具备竞争力，但是阿里云轻量应用服务器香港区目前的线路质量实在堪忧，需要绕日本NTT，目测已经被玩坏，因此总体而言并不推荐大家使用。当然这仅仅是我个人的看法，对测试结果有不同意见的朋友也欢迎私信，后续我计划再测试一下其他地域(如新加坡)的阿里云轻量应用服务器。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 性能测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 性能测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搜索超时</title>
      <link href="2020/12/02/Git&amp;GitHub/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Github%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
      <url>2020/12/02/Git&amp;GitHub/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Github%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近几天的GitHub提交出了些问题，导致之前提交的更新丢失，考虑回退到之前的版本。在GitHub的Web页面上并没有找到回退的解决方案（如果大家知道的话，感谢告知），于是决定通过本地的 Git Bash来操作。</p><ul><li><p><strong>查找 commit id：</strong>浏览GitHub上的提交历史记录，找到要回退的版本，复制commit id。</p><p>  类似这种</p><p>  <img src="https://s3.ax1x.com/2020/12/02/DI4MQ0.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/02/DI4MQ0.jpg" srcset="data:image/png;base64,666" alt="这里写图片描述"></p></li></ul><ul><li><strong>恢复历史版本：</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">git reset --hard [你的commit id] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>push：</strong>推送到GitHub远程仓库</li></ul><pre class="line-numbers language-none"><code class="language-none">git push -f -u origin master <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搜索超时</title>
      <link href="2020/12/02/Linux/%E9%97%AE%E9%A2%98/Docker%E6%90%9C%E7%B4%A2%E8%B6%85%E6%97%B6/"/>
      <url>2020/12/02/Linux/%E9%97%AE%E9%A2%98/Docker%E6%90%9C%E7%B4%A2%E8%B6%85%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker搜索超时"><a href="#Docker搜索超时" class="headerlink" title="Docker搜索超时"></a>Docker搜索超时</h2><p>执行<code>docker search centos</code>报错信息如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Error response from daemon: Get https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;search?q&#x3D;centos: read tcp 52.200.132.201:443: i&#x2F;o timeout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>docker在中国已经有了仓库：<a href="https://www.docker-cn.com/registry-mirror">https://www.docker-cn.com/registry-mirror</a></p><p>根据上面网站提供的修改方法。</p><p>进入<code>/etc/docker</code>目录下</p><p>查看有没有 daemon.json。这是docker默认的配置文件。</p><p>如果没有新建，如果有，则修改。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#123;  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>保存退出。</p><p>重启docker服务：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">service docker restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 镜像源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将linux的HOME目录下的文件夹名字改回英文的简单办法</title>
      <link href="2020/12/02/Linux/%E9%97%AE%E9%A2%98/%E5%B0%86linux%E7%9A%84%E7%94%A8%E6%88%B7%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/"/>
      <url>2020/12/02/Linux/%E9%97%AE%E9%A2%98/%E5%B0%86linux%E7%9A%84%E7%94%A8%E6%88%B7%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="将linux的HOME目录下的文件夹名字改回英文的简单办法"><a href="#将linux的HOME目录下的文件夹名字改回英文的简单办法" class="headerlink" title="将linux的HOME目录下的文件夹名字改回英文的简单办法"></a>将linux的HOME目录下的文件夹名字改回英文的简单办法</h2><p>为了使用起来方便，装了Ubuntu中文版，自然在home文件里用户目录的“桌面”、“图片”、“视频”、“音乐”……都是中文的。很多时候都喜欢在桌面上放一些要操作的文件，linux里命令行操作又多，难免会用命令行操作桌面上的东西，那么就要 “cd 桌面”，打“桌面”的时候要输入法切换，麻烦……</p><p>所以就想办法把用户目录下的路径改成英文，而其他的中文不变， 方法如下：</p><p>　　打开终端，在终端中输入命令:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export LANG&#x3D;en_US# 更改语言为英文xdg-user-dirs-gtk-update# 更新<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>跳出对话框询问是否将目录转化为英文路径,同意并关闭.</p><p>　　在终端中输入命令:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export LANG&#x3D;zh_CN# 更改语言为中文<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        重启系统。或者再次运行　<code>xdg-user-dirs-gtk-update</code></p><p>系统会提示是否把转化好的目录改回中文，选择不再提示,并取消修改.主目录的中文转英文就完成了.</p><hr><p>在有些linux发行板中，上面的命令无法使用，不过我们可以动过手动修改的方式达到，具体方法路下：</p><p>​        找到～/.config/user-dirs.dis文件（注：~/代表当前用户目录  .config是个隐藏文件）<br>​        将该文件中的中文改成对应的英文<br>​        再在～/目录下创建对应的英文文件夹，重启就可以了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="2020/12/02/Git&amp;GitHub/git%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/02/Git&amp;GitHub/git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本片笔记基于B站up主<code>狂神说java</code>编写</p></blockquote><p>先了解下什么是版本控制</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>多人开发就必须要使用版本控制！</p><h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p><p>主流的版本控制器有如下这些：</p><ul><li><strong>Git</strong></li><li><strong>SVN</strong>（Subversion）</li><li><strong>CVS</strong>（Concurrent Versions System）</li><li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li><li><strong>TFS</strong>（Team Foundation Server）</li><li>Visual Studio Online</li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><strong>2、集中版本控制  SVN</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><strong>3、分布式版本控制     Git</strong></p><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><h2 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p>**<br>**</p><p>聊聊Git的历史</p><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p><p>Git环境配置</p><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>打开 [git官网] <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p><p>所有东西下载慢的话就可以去找镜像！</p><p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0IXktseBR7lpvVF4bibFwiaibnGxkDm0wYicPIiaZxcUe2KuibAHj83MiaWFSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0IXktseBR7lpvVF4bibFwiaibnGxkDm0wYicPIiaZxcUe2KuibAHj83MiaWFSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>下载对应的版本即可安装！</p><p>安装：无脑下一步即可！安装完毕就可以使用了！</p><h2 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD：</strong>Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p><p>1）、cd : 改变目录。</p><p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p><p>3）、pwd : 显示当前所在的目录路径。</p><p>4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）、mkdir:  新建一个目录,就是新建一个文件夹。</p><p>8）、rm -r :  删除一个文件夹, rm -r src 删除src目录</p><pre class="line-numbers language-none"><code class="language-none">rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p><p>10）、reset 重新初始化终端/清屏。</p><p>11）、clear 清屏。</p><p>12）、history 查看命令历史。</p><p>13）、help 帮助。</p><p>14）、exit 退出。</p><p>15）、#表示注释</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>所有的配置文件，其实都保存在本地！</p><p>查看配置 git config -l</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>查看不同级别的配置文件：</p><ul><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">#查看系统configgit config --system --list　　#查看当前用户（global）配置git config --global  --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Git相关的配置文件：</strong></p><p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p><p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p><h2 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><ul><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;kuangshen&quot;  #名称git config --global user.email 24736743@qq.com   #邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0zQZY37q1iaG0n7445X8YgPVvZH5AqyGvT4RgmoyIcZlJWiaLcxyDgSdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0zQZY37q1iaG0n7445X8YgPVvZH5AqyGvT4RgmoyIcZlJWiaLcxyDgSdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Git基本理论（重要）</p><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0icz6X2aibIgUWzHxtwX8kicPCKpDrsiaPzZk04OlI2bzlydzicBuXTJvLEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0icz6X2aibIgUWzHxtwX8kicPCKpDrsiaPzZk04OlI2bzlydzicBuXTJvLEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Git项目搭建</p><h2 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h2><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><ul><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 在当前目录新建一个Git代码库$ git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><ul><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]  # https:&#x2F;&#x2F;gitee.com&#x2F;kuangstudy&#x2F;openclass.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、去 gitee 或者 github 上克隆一个测试！</p><p>Git文件操作</p><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">#查看指定文件状态git status [filename]#查看所有文件状态git status# git add .                  添加所有文件到暂存区# git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><ul><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">#为注释*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt     #但lib.txt除外&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild&#x2F;       #忽略build&#x2F;目录下的所有文件doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用码云</p><h2 id="github-是有墙的，比较慢，在国内的话，我们一般使用-gitee-，公司中有时候会搭建自己的gitlab服务器"><a href="#github-是有墙的，比较慢，在国内的话，我们一般使用-gitee-，公司中有时候会搭建自己的gitlab服务器" class="headerlink" title="github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器"></a>github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器</h2><p>这个其实可以作为大家未来找工作的一个重要信息！</p><p>1、注册登录码云，完善个人信息</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ebAqhteskG4GHwD01bX4lXYmxlmMGn8PRqn4aCXfaQdp3SnbBHdibtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ebAqhteskG4GHwD01bX4lXYmxlmMGn8PRqn4aCXfaQdp3SnbBHdibtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p><ul><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 进入 C:\Users\Administrator\.ssh 目录# 生成公钥ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>3、将公钥信息public key 添加到码云账户中即可！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0I5Zicrm4PEbnox9L5wjCPtPybCyrKI1JOkRWCYIY5zsX4FvI77LXXmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0I5Zicrm4PEbnox9L5wjCPtPybCyrKI1JOkRWCYIY5zsX4FvI77LXXmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>4、使用码云创建一个自己的仓库！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0FSIwJb9g6Qbp99jY605xdPfh3N4l2rGpD44d6NCcdibankBUL60uODg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0FSIwJb9g6Qbp99jY605xdPfh3N4l2rGpD44d6NCcdibankBUL60uODg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，…  限制！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0S96XfGogNWVqRAexeybT7DXdyQhfcYJ1oEAgaH1RibRU0WZE0eczdxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0S96XfGogNWVqRAexeybT7DXdyQhfcYJ1oEAgaH1RibRU0WZE0eczdxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>克隆到本地！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0PyKfGFd8UHSGIRbVLkXH5icQsgxh6K2RPibYeUER54UzuNVAYsgxXcfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0PyKfGFd8UHSGIRbVLkXH5icQsgxh6K2RPibYeUER54UzuNVAYsgxXcfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>IDEA中集成Git</p><p>1、新建项目，绑定git。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0D8LPGu2SNKXD01IMqDaSkBeP8ibtvnasBYiaReyuZWAl0EjEib8IYf7cQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0D8LPGu2SNKXD01IMqDaSkBeP8ibtvnasBYiaReyuZWAl0EjEib8IYf7cQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>注意观察idea中的变化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Cs93BiaOia1Sdk8icdH7vQzPfzIjuoTNYquKzYtrEe5mklhg2b7KOYsow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Cs93BiaOia1Sdk8icdH7vQzPfzIjuoTNYquKzYtrEe5mklhg2b7KOYsow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>2、修改文件，使用IDEA操作git。</p><ul><li>添加到暂存区</li><li>commit 提交</li><li>push到远程仓库</li></ul><p>3、提交测试</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0tERIszdgLVlUWamyRapfN74aR8XeGFV2OYWiaeR9CkYlfoBefRh2AIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0tERIszdgLVlUWamyRapfN74aR8XeGFV2OYWiaeR9CkYlfoBefRh2AIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>这些都是单个人的操作！</p><p>学习的方式最重要！学会学习！我上课的更多时候都是在教大家去学习一种理念和思想（学习方式）</p><p>有道无术、术尚可求。有术无道、止于术！</p><p>真正的教学，授人以渔！</p><h2 id="说明：GIT分支"><a href="#说明：GIT分支" class="headerlink" title="说明：GIT分支"></a>说明：GIT分支</h2><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0BOGzaG4QTc4JXO0hSlwcNtujNzAvxeibSrajLYLCT6otNnHDV9xYWwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0BOGzaG4QTc4JXO0hSlwcNtujNzAvxeibSrajLYLCT6otNnHDV9xYWwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Ayn87woxfepOhSlUj4FQTFUsia4ic0j6aQy4Tz32PRuJ0HSVeGeUzURA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Ayn87woxfepOhSlUj4FQTFUsia4ic0j6aQy4Tz32PRuJ0HSVeGeUzURA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>git分支中常用指令：</p><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote&#x2F;branch]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IDEA中操作</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0wHNIYeTHC8aHGASoDyZO64QicslqiaMb1OJ1Z1LPoic3LBGyDIYBa7XXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0wHNIYeTHC8aHGASoDyZO64QicslqiaMb1OJ1Z1LPoic3LBGyDIYBa7XXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p>作业练习：找一个小伙伴，一起搭建一个远程仓库，来练习Git！</p><p>1、不要把Git想的很难，工作中多练习使用就自然而然的会了！</p><p>2、Git的学习也十分多，看完我的Git教程之后，可以多去思考，总结到自己博客！</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令收集</title>
      <link href="2020/12/02/Linux/%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/"/>
      <url>2020/12/02/Linux/%E5%91%BD%E4%BB%A4%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大部分文档来自<a href="https://man.linuxde.net/">https://man.linuxde.net/</a></p><h2 id="命令收集"><a href="#命令收集" class="headerlink" title="命令收集"></a>命令收集</h2><p>linux使用命令   find / -name ***  查找文件的时候会遇到以下报错</p><p>find: ‘/run/user/1000/gvfs’: Permission denied   </p><p>明明用的是root用户，为什么权限不足呢？</p><p>官方说这是一个bug——bug#615848. 原因是FUSE文件系统和权限不配的问题，全局搜索时碰到它就会退出报错。</p><p>其实这个目录是空的，查不查都没关系。所以,以下解决方式比较简直暴</p><p>umount /run/user/1000/gvfs</p><p>rm -rf /run/user/1000/gvfs</p><p>现在，你再使用命令   find / -name ***  查找东西是不是就爽多了。</p><p><strong>一次删除所有目录的目标文件或文件夹：</strong></p><p><strong>find / -name \</strong>*|xargs rm -rf//*<em>\</em>为你要删除的文件或文件夹**</p><p><strong>相信这个命令在你要彻底卸载某个程序的时候会有帮助。</strong></p><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>分类：文件和目录管理</p><p>功能：用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">find(选项)(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><pre class="line-numbers language-none"><code class="language-none">-name&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；-cmin&lt;分钟&gt;：查找在指定时间之时被更改过的文件或目录；-ctime&lt;24小时数&gt;：查找在指定时间之时被更改的文件或目录，单位以24小时计算；-daystart：从本日开始计算时间；-depth：从指定目录下最深层的子目录开始查找；-empty：寻找文件大小为0 Byte的文件，或目录下没有任何子目录或文件的空目录；-exec&lt;执行指令&gt;：假设find指令的回传值为True，就执行该指令；-false：将find指令的回传值皆设为False；-fls&lt;列表文件&gt;：此参数的效果和指定“-ls”参数类似，但会把结果保存为指定的列表文件；-follow：排除符号连接；-fprint&lt;列表文件&gt;：此参数的效果和指定“-print”参数类似，但会把结果保存成指定的列表文件；-fprint0&lt;列表文件&gt;：此参数的效果和指定“-print0”参数类似，但会把结果保存成指定的列表文件；-fprintf&lt;列表文件&gt;&lt;输出格式&gt;：此参数的效果和指定“-printf”参数类似，但会把结果保存成指定的列表文件；-fstype&lt;文件系统类型&gt;：只寻找该文件系统类型下的文件或目录；-gid&lt;群组识别码&gt;：查找符合指定之群组识别码的文件或目录；-group&lt;群组名称&gt;：查找符合指定之群组名称的文件或目录；-help或——help：在线帮助；-ilname&lt;范本样式&gt;：此参数的效果和指定“-lname”参数类似，但忽略字符大小写的差别；-iname&lt;范本样式&gt;：此参数的效果和指定“-name”参数类似，但忽略字符大小写的差别；-inum&lt;inode编号&gt;：查找符合指定的inode编号的文件或目录；-ipath&lt;范本样式&gt;：此参数的效果和指定“-path”参数类似，但忽略字符大小写的差别；-iregex&lt;范本样式&gt;：此参数的效果和指定“-regexe”参数类似，但忽略字符大小写的差别；-links&lt;连接数目&gt;：查找符合指定的硬连接数目的文件或目录；-iname&lt;范本样式&gt;：指定字符串作为寻找符号连接的范本样式；-ls：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出；-maxdepth&lt;目录层级&gt;：设置最大目录层级；-mindepth&lt;目录层级&gt;：设置最小目录层级；-mmin&lt;分钟&gt;：查找在指定时间曾被更改过的文件或目录，单位以分钟计算；-mount：此参数的效果和指定“-xdev”相同；-mtime&lt;24小时数&gt;：查找在指定时间曾被更改过的文件或目录，单位以24小时计算；-newer&lt;参考文件或目录&gt;：查找其更改时间较指定文件或目录的更改时间更接近现在的文件或目录；-nogroup：找出不属于本地主机群组识别码的文件或目录；-noleaf：不去考虑目录至少需拥有两个硬连接存在；-nouser：找出不属于本地主机用户识别码的文件或目录；-ok&lt;执行指令&gt;：此参数的效果和指定“-exec”类似，但在执行指令之前会先询问用户，若回答“y”或“Y”，则放弃执行命令；-path&lt;范本样式&gt;：指定字符串作为寻找目录的范本样式；-perm&lt;权限数值&gt;：查找符合指定的权限数值的文件或目录；-print：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为每列一个名称，每个名称前皆有“.&#x2F;”字符串；-print0：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式为全部的名称皆在同一行；-printf&lt;输出格式&gt;：假设find指令的回传值为Ture，就将文件或目录名称列出到标准输出。格式可以自行指定；-prune：不寻找字符串作为寻找文件或目录的范本样式;-regex&lt;范本样式&gt;：指定字符串作为寻找文件或目录的范本样式；-size&lt;文件大小&gt;：查找符合指定的文件大小的文件；-true：将find指令的回传值皆设为True；-type&lt;文件类型&gt;：只寻找符合指定的文件类型的文件；-uid&lt;用户识别码&gt;：查找符合指定的用户识别码的文件或目录；-used&lt;日数&gt;：查找文件或目录被更改之后在指定时间曾被存取过的文件或目录，单位以日计算；-user&lt;拥有者名称&gt;：查找符和指定的拥有者名称的文件或目录；-version或——version：显示版本信息；-xdev：将范围局限在先行的文件系统中；-xtype&lt;文件类型&gt;：此参数的效果和指定“-type”参数类似，差别在于它针对符号连接检查。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>起始目录：查找文件的起始目录。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li>根据文件或者正则表达式进行匹配</li></ul><p>列出当前目录及子目录下所有文件和文件夹</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">find .<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>/home</code>目录下查找以.txt结尾的文件名</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">find &#x2F;home -name &quot;*.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同上，但忽略大小写</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F;home -iname &quot;*.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当前目录及子目录下查找所有以.txt和.pdf结尾的文件</p><pre class="line-numbers language-none"><code class="language-none">find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)或find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>匹配文件路径或者文件</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F;usr&#x2F; -path &quot;*local*&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>基于正则表达式匹配文件路径</p><pre class="line-numbers language-none"><code class="language-none">find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同上，但忽略大小写</p><pre class="line-numbers language-none"><code class="language-none">find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>否定参数</li></ul><p>找出/home下不是以.txt结尾的文件</p><pre class="line-numbers language-none"><code class="language-none">find &#x2F;home ! -name &quot;*.txt&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>根据文件类型进行搜索</li></ul><pre class="line-numbers language-none"><code class="language-none">find . -type 类型参数<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>类型参数列表：</p><ul><li><p><strong>f</strong> 普通文件</p></li><li><p><strong>l</strong> 符号连接</p></li><li><p><strong>d</strong> 目录</p></li><li><p><strong>c</strong> 字符设备</p></li><li><p><strong>b</strong> 块设备</p></li><li><p><strong>s</strong> 套接字</p></li><li><p><strong>p</strong> Fifo</p></li><li><p>基于目录深度搜索</p></li></ul><p>向下最大深度限制为3</p><pre class="line-numbers language-none"><code class="language-none">find . -maxdepth 3 -type f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索出深度距离当前目录至少2个子目录的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -mindepth 2 -type f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>根据文件时间戳进行搜索</li></ul><pre class="line-numbers language-none"><code class="language-none">find . -type f 时间戳<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>UNIX/Linux文件系统每个文件都有三种时间戳：</p><ul><li><strong>访问时间</strong>（-atime/天，-amin/分钟）：用户最近一次访问时间。</li><li><strong>修改时间</strong>（-mtime/天，-mmin/分钟）：文件最后一次修改时间。</li><li><strong>变化时间</strong>（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。</li></ul><p>搜索最近七天内被访问过的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -atime -7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索恰好在七天前被访问过的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -atime 7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索超过七天内被访问过的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -atime +7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索访问时间超过10分钟的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -amin +10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找出比<a href="http://man.linuxde.net/file">file</a>.log修改时间更长的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -newer file.log<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>根据文件大小进行匹配</li></ul><pre class="line-numbers language-none"><code class="language-none">find . -type f -size 文件大小单元<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>文件大小单元：</p><ul><li><strong>b</strong> —— 块（512字节）</li><li><strong>c</strong> —— 字节</li><li><strong><a href="http://man.linuxde.net/w">w</a></strong> —— 字（2字节）</li><li><strong>k</strong> —— 千字节</li><li><strong>M</strong> —— 兆字节</li><li><strong>G</strong> —— 吉字节</li></ul><p>搜索大于10KB的文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -size +10k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索小于10KB的文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -size -10k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>搜索等于10KB的文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -size 10k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除匹配文件"><a href="#删除匹配文件" class="headerlink" title="删除匹配文件"></a>删除匹配文件</h4><p>删除当前目录下所有.txt文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -name &quot;*.txt&quot; -delete<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="根据文件权限-所有权进行匹配"><a href="#根据文件权限-所有权进行匹配" class="headerlink" title="根据文件权限/所有权进行匹配"></a>根据文件权限/所有权进行匹配</h4><p>当前目录下搜索出权限为777的文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -perm 777<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找出当前目录下权限不是644的<a href="http://man.linuxde.net/php">php</a>文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -name &quot;*.php&quot; ! -perm 644<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找出当前目录用户tom拥有的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -user tom<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找出当前目录用户组sunk拥有的所有文件</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -group sunk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="借助-exec选项与其他命令结合使用"><a href="#借助-exec选项与其他命令结合使用" class="headerlink" title="借助-exec选项与其他命令结合使用"></a>借助<code>-exec</code>选项与其他命令结合使用</h4><p>找出当前目录下所有root的文件，并把所有权更改为用户tom</p><pre class="line-numbers language-none"><code class="language-none">find .-type f -user root -exec chown tom &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上例中，**{}** 用于与**-exec**选项结合使用来匹配所有文件，然后会被替换为相应的文件名。</p><p>找出自己家目录下所有的.txt文件并删除</p><pre class="line-numbers language-none"><code class="language-none">find $HOME&#x2F;. -name &quot;*.txt&quot; -ok rm &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上例中，**-ok<strong>和</strong>-exec**行为一样，不过它会给出提示，是否执行相应的操作。</p><p>查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -name &quot;*.txt&quot; -exec cat &#123;&#125; \;&gt; all.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将30天前的.log文件移动到old目录中</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp &#123;&#125; old \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来</p><pre class="line-numbers language-none"><code class="language-none">find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令</p><pre class="line-numbers language-none"><code class="language-none">-exec .&#x2F;text.sh &#123;&#125; \;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="搜索但跳出指定的目录"><a href="#搜索但跳出指定的目录" class="headerlink" title="搜索但跳出指定的目录"></a>搜索但跳出指定的目录</h4><p>查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk</p><pre class="line-numbers language-none"><code class="language-none">find . -path &quot;.&#x2F;sk&quot; -prune -o -name &quot;*.txt&quot; -print<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="find其他技巧收集"><a href="#find其他技巧收集" class="headerlink" title="find其他技巧收集"></a>find其他技巧收集</h4><p>要列出所有长度为零的文件</p><pre class="line-numbers language-none"><code class="language-none">find . -empty<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="用户和工作组管理"><a href="#用户和工作组管理" class="headerlink" title="用户和工作组管理"></a>用户和工作组管理</h1><h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p><a href="https://man.linuxde.net/sub/%E7%94%A8%E6%88%B7%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%BB%84%E7%AE%A1%E7%90%86">用户和工作组管理</a></p><p><strong>useradd命令</strong>用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用<a href="http://man.linuxde.net/passwd">passwd</a>设定帐号的密码．而可用<a href="http://man.linuxde.net/userdel">userdel</a>删除帐号。使用useradd指令所建立的帐号，实际上是保存在<code>/etc/passwd</code>文本文件中。</p><p>在Slackware中，adduser指令是个script程序，利用交谈的方式取得输入的用户帐号资料，然后再交由真正建立帐号的useradd命令建立新用户，如此可方便管理员建立用户帐号。在Red Hat Linux中，<strong>adduser命令</strong>则是useradd命令的符号连接，两者实际上是同一个指令。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">useradd(选项)(参数)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；-d&lt;登入目录&gt;：指定用户登入时的启始目录；-D：变更预设值；-e&lt;有效期限&gt;：指定帐号的有效期限；-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；-g&lt;群组&gt;：指定用户所属的群组；-G&lt;群组&gt;：指定用户所属的附加群组；-m：自动建立用户的登入目录；-M：不要自动建立用户的登入目录；-n：取消建立以用户名称为名的群组；-r：建立系统帐号；-s&lt;shell&gt;：指定用户登入后所使用的shell；-u&lt;uid&gt;：指定用户id。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>用户名：要创建的用户名。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>新建用户加入组：</p><pre class="line-numbers language-none"><code class="language-none">useradd –g sales jack –G company,employees    &#x2F;&#x2F;-g：加入主要组、-G：加入次要组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>建立一个新用户账户，并设置ID：</p><pre class="line-numbers language-none"><code class="language-none">useradd caojh -u 544<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要说明的是，设定ID值时尽量要大于500，以免冲突。因为Linux安装后会建立一些特殊用户，一般0到499之间的值留给bin、<a href="http://man.linuxde.net/mail">mail</a>这样的系统账号。</p><h1 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h1><h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>对服务的操作</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">service [服务名] restart# 重启服务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>对服务的操作</p><p>适用系统：CentOS</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl status [服务名]  # 查看服务状态systemctl start [服务名]# 启动服务systemctl stop [服务名]# 停止服务systemctl restart [服务名]# 重启服务systemctl enable [服务名]# 设置服务开机启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="images"><a href="#images" class="headerlink" title="images"></a>images</h2><p>查看镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>REPOSITORY：镜像名称</p><p>TAG：镜像标签</p><p>IMAGE ID：镜像ID</p><p>ACREATED：镜像的创建日期（不是获取该镜像的日期）</p><p>SIZE：镜像大小</p><p>这些镜像都储存在Docker宿主机的/var/lib/docker目录下</p><h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>搜索镜像</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker search [镜像名称]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>INDEX：仓库源</p><p>NAME：仓库名称</p><p>DESCRIPTION：镜像描述</p><p>STARS：用户评价，反映一个镜像的受欢迎程度</p><p>OFFICIAL：是否官方</p><p>AUTOMATED：自动构建，表示该镜像是由Docker Hub自动构建流程创建的</p><h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>拉取镜像：从中央仓库下载镜像到本地</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker pull [镜像名称]例如:要下载centos7镜像docker pull centos:7<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p><strong>df命令</strong>用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">df [选项] [参数]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h3><pre class="line-numbers language-none"><code class="language-none">-a或--all：包含全部的文件系统；--block-size&#x3D;&lt;区块大小&gt;：以指定的区块大小来显示区块数目；-h或--human-readable：以可读性较高的方式来显示信息；-H或--si：与-h参数相同，但在计算时是以1000 Bytes为换算单位而非1024 Bytes；-i或--inodes：显示inode的信息；-k或--kilobytes：指定区块大小为1024字节；-l或--local：仅显示本地端的文件系统；-m或--megabytes：指定区块大小为1048576字节；--no-sync：在取得磁盘使用信息前，不要执行sync指令，此为预设值；-P或--portability：使用POSIX的输出格式；--sync：在取得磁盘使用信息前，先执行sync指令；-t&lt;文件系统类型&gt;或--type&#x3D;&lt;文件系统类型&gt;：仅显示指定文件系统类型的磁盘信息；-T或--print-type：显示文件系统的类型；-x&lt;文件系统类型&gt;或--exclude-type&#x3D;&lt;文件系统类型&gt;：不要显示指定文件系统类型的磁盘信息；--help：显示帮助；--version：显示版本信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p>文件：指定文件系统上的文件。</p><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>查看系统磁盘设备，默认是KB为单位：</p><pre class="line-numbers language-none"><code class="language-none">[root@LinServ-1 ~]# df文件系统               1K-块        已用     可用 已用% 挂载点&#x2F;dev&#x2F;sda2            146294492  28244432 110498708  21% &#x2F;&#x2F;dev&#x2F;sda1              1019208     62360    904240   7% &#x2F;boottmpfs                  1032204         0   1032204   0% &#x2F;dev&#x2F;shm&#x2F;dev&#x2F;sdb1            2884284108 218826068 2518944764   8% &#x2F;data1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>-h</code>选项以KB以上的单位来显示，可读性高：</p><pre class="line-numbers language-none"><code class="language-none">[root@LinServ-1 ~]# df -h文件系统              容量  已用 可用 已用% 挂载点&#x2F;dev&#x2F;sda2             140G   27G  106G  21% &#x2F;&#x2F;dev&#x2F;sda1             996M   61M  884M   7% &#x2F;boottmpfs                1009M     0 1009M   0% &#x2F;dev&#x2F;shm&#x2F;dev&#x2F;sdb1             2.7T  209G  2.4T   8% &#x2F;data1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看全部文件系统：</p><pre class="line-numbers language-none"><code class="language-none">[root@LinServ-1 ~]# df -a文件系统               1K-块        已用     可用 已用% 挂载点&#x2F;dev&#x2F;sda2            146294492  28244432 110498708  21% &#x2F;proc                         0         0         0   -  &#x2F;procsysfs                        0         0         0   -  &#x2F;sysdevpts                       0         0         0   -  &#x2F;dev&#x2F;pts&#x2F;dev&#x2F;sda1              1019208     62360    904240   7% &#x2F;boottmpfs                  1032204         0   1032204   0% &#x2F;dev&#x2F;shm&#x2F;dev&#x2F;sdb1            2884284108 218826068 2518944764   8% &#x2F;data1none                         0         0         0   -  &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p><strong>du命令</strong>也是查看使用空间的，但是与<a href="http://man.linuxde.net/df">df</a>命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的。</p><h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">du [选项] [文件]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="选项-3"><a href="#选项-3" class="headerlink" title="选项"></a>选项</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-k或--kilobytes 以KB(1024bytes)为单位输出。-m或--megabytes 以MB为单位输出。-s或--summarize 仅显示总计，只列出最后加总的值。-h或--human-readable 以K，M，G为单位，提高信息的可读性。-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-X&lt;文件&gt;或--exclude-from&#x3D;&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。--exclude&#x3D;&lt;目录或文件&gt; 略过指定的目录或文件。-D或--dereference-args 显示指定符号链接的源文件大小。-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。-l或--count-links 重复计算硬件链接的文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>显示目录或者文件所占空间：</p><pre class="line-numbers language-none"><code class="language-none">[root@localhost test]# du608 .&#x2F;test6308 .&#x2F;test44 .&#x2F;scf&#x2F;lib4 .&#x2F;scf&#x2F;service&#x2F;deploy&#x2F;product4 .&#x2F;scf&#x2F;service&#x2F;deploy&#x2F;info12 .&#x2F;scf&#x2F;service&#x2F;deploy16 .&#x2F;scf&#x2F;service4 .&#x2F;scf&#x2F;doc4 .&#x2F;scf&#x2F;bin32 .&#x2F;scf8 .&#x2F;test31288 .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小</p><p>显示指定文件所占空间：</p><pre class="line-numbers language-none"><code class="language-none">[root@localhost test]# du log2012.log300 log2012.log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>查看指定目录的所占空间：</p><pre class="line-numbers language-none"><code class="language-none">[root@localhost test]# du scf4 scf&#x2F;lib4 scf&#x2F;service&#x2F;deploy&#x2F;product4 scf&#x2F;service&#x2F;deploy&#x2F;info12 scf&#x2F;service&#x2F;deploy16 scf&#x2F;service4 scf&#x2F;doc4 scf&#x2F;bin32 scf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显示多个文件所占空间：</p><pre class="line-numbers language-none"><code class="language-none">[root@localhost test]# du log30.tar.gz log31.tar.gz4 log30.tar.gz4 log31.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>只显示总和的大小:</p><pre class="line-numbers language-none"><code class="language-none">[root@localhost test]# du -s1288 .[root@localhost test]# du -s scf32 scf[root@localhost test]# cd ..[root@localhost soft]# du -s test1288 test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="2020/12/02/Linux/Linux/"/>
      <url>2020/12/02/Linux/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="文件-目录"><a href="#文件-目录" class="headerlink" title="文件/目录"></a>文件/目录</h2><blockquote><p>cd    切换目录</p><blockquote><p>语法: </p></blockquote><p>find        查找文件或目录</p><blockquote><p>语法    find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \</p><p>例子<br>find . -name “*.c”</p></blockquote></blockquote><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>更新包信息，确保APT能使用https方式工作，并且CA证书已安装了</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get update # 更新包信息sudo apt-get install apt-transport-https ca-certificates<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><p>笔者常用Linux系统为Ubuntu , 某些命令是其特有的</p><h3 id="文件-文件夹"><a href="#文件-文件夹" class="headerlink" title="文件/文件夹"></a>文件/文件夹</h3><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>切换当前工作目录至 dirName(目录参数)。其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">示例:cd # 相当于 &#39;cd ~&#39; 进入当前用户主目录cd &#x2F;rootcd ..&#x2F;..<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>用于连接文件并打印到标准输出设备上。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat [-AbeEnstTuv] [--help] [--version] fileName参数说明：    -n 或 --number：由 1 开始对所有输出的行数编号。    -b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。    -s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。    -v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。    -E 或 --show-ends : 在每行结束处显示 $。    -T 或 --show-tabs: 将 TAB 字符显示为 ^I。    -A, --show-all：等价于 -vET。    -e：等价于&quot;-vE&quot;选项；    -t：等价于&quot;-vT&quot;选项；示例:# 把 file1 的文档内容加上行号后输入 file2 这个文档里：cat -n file1 &gt; textfile2# 把&#39;file1&#39;和&#39;file2&#39;的文件内容加上行号(空白行不加)之后附加到&#39;file3&#39;里：cat -b file1 textfile2 &gt;&gt; textfile3# 清空 &#x2F;etc&#x2F;test.txt 文档内容：cat &#x2F;dev&#x2F;null &gt; &#x2F;etc&#x2F;test.txtcat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：    cat &#x2F;dev&#x2F;fd0 &gt; OUTFILE    相反的，如果想把 image file 写到软盘，输入：    cat IMG_FILE &gt; &#x2F;dev&#x2F;fd0注：    1. OUTFILE 指输出的镜像文件名。    2. IMG_FILE 指镜像文件。    3. 若从镜像文件写回 device 时，device 容量需与相当。    4. 通常用制作开机磁片。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>用来为文件或目录改名、或将文件或目录移入其它位置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv [options] source destmv [options] source... directory参数说明：    -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;    -f: 在 mv 操作要覆盖某已有的目标文件时不给任何指示;mv参数设置与运行结果    mv 文件名 文件名: 将源文件名改为目标文件名    mv 文件名 目录名: 将文件移动到目标目录    mv 目录名 目录名: 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名    mv 目录名 文件名: 出错示例:    # 将文件 aaa 更名为 bbb    mv aaa bbb    # 将info目录放入logs目录中。注意，如果logs目录不存在，则该命令将info改名为logs    mv info&#x2F; logs     # 再如将&#x2F;usr&#x2F;student下的所有文件和目录移到当前目录下，命令行为    mv &#x2F;usr&#x2F;student&#x2F;*  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>用于删除一个文件或者目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm [options] name...参数：    -i 删除前逐一询问确认。    -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。    -r 将目录及以下之档案亦逐一删除。示例:# 删除文件可以直接使用rm命令，若删除目录则必须配合选项&quot;-r&quot;，例如：    rm  test.txt     rm：是否删除 一般文件 &quot;test.txt&quot;? y      rm  homework      rm: 无法删除目录&quot;homework&quot;: 是一个目录      rm  -r  homework      rm：是否删除 目录 &quot;homework&quot;? y         # 删除当前目录下的所有文件及目录，命令行为：rm  -r  *# 删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认命令行为：rm  -rf  要删除的文件名或目录        #删除文件名 test.txt:        rm  -rf   test.txt        # 删除目录 test，不管该目录下是否有子目录或文件，都直接删除:        rm  -rf   test&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>显示当前所在目录</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>新建文件夹</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>新建空白文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">touch  # 新建空白文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>查找文件/文件夹</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">find [PATH] [Option] [action]    -newer file:file为一个存在的文件，列出比file还要新的文件名    find &#x2F; -mtime 0———0代表当前的时间，即从现在开始到24小时前，有改动过内容的文件都会被列出来    find &#x2F;etc -newer &#x2F;etc&#x2F;passwd———寻找&#x2F;etc下面的文件，如果文件日期比&#x2F;etc&#x2F;passwd新就列出    find &#x2F; -name file——&#x2F;代表全文搜索    find &#x2F;home -user Anmy——查找&#x2F;home下属于Anmy的文件    find &#x2F; -nouser—— 查找系统中不属于任何人的文件，可以轻易找出那些不太正常的文件    find &#x2F; -name passed—— 查找文件名为passed的文件find其他参数：    -type TYPE: 查找文件类型为TYPE的，类型主要有：一般正规文件(f)、设备文件(b,c)、目录(d)、连接文件(l)、socket（s）及FIFO(p)等属性    -perm mode: 查找文件权限刚好等于mode的文件    -perm +mode:查找文件权限“包含任一mode的权限”的文件。    -perm -mode:查找文件权限“必须要全部包括mode的权限”的文件。find后其他可进行的操作：    -exec command:command为其他命令，-exec后面可再接其他的命令来处理查找到的结果。    -print:将结果打印到屏幕上，为默认操作。示例:find &#x2F; -name &#39;aaa&#39; -type d# 在&#39;&#x2F;&#39;目录下查找名字为&#39;aaa&#39;的目录find &#x2F; -name &#39;server.xml&#39; -print # 查找server.xml文件的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="用户-权限"><a href="#用户-权限" class="headerlink" title="用户/权限"></a>用户/权限</h3><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>切换用户,默认为root</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">示例:    su  # 切换为root用户    su kvm # 切换成用户名为&#39;kvm&#39;的用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>以root权限执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">示例:sudo apt update<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>显示当前系统时间</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">date # 打印结果如下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src=".static/imgs/Linux/image-20200128122202297.png" class="lazyload" data-srcset=".static/imgs/Linux/image-20200128122202297.png" srcset="data:image/png;base64,666" alt="image-20200128122202297"></p><h4 id="cal-ncal"><a href="#cal-ncal" class="headerlink" title="cal/ncal"></a>cal/ncal</h4><p>打印日历</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">示例:cal # 打印当前月日历cal 8 2017 # 打印2017年8月的日历ncal  # 转置的日历ncal -C  # 正过来了(-_-)!!!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src=".static/imgs/Linux/image-20200128122401693.png" class="lazyload" data-srcset=".static/imgs/Linux/image-20200128122401693.png" srcset="data:image/png;base64,666" alt="image-20200128122401693"><img src=".static/imgs/Linux/image-20200128122620156.png" class="lazyload" data-srcset=".static/imgs/Linux/image-20200128122620156.png" srcset="data:image/png;base64,666" alt=" "><img src=".static/imgs/Linux/image-20200128122838383.png" class="lazyload" data-srcset=".static/imgs/Linux/image-20200128122838383.png" srcset="data:image/png;base64,666"></p><p><img src=".static/imgs/Linux/image-20200128122925491.png" class="lazyload" data-srcset=".static/imgs/Linux/image-20200128122925491.png" srcset="data:image/png;base64,666" alt="image-20200128122925491"></p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">unameuname -auname -r<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sl  # 小火车(需要安装)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>linux</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat &#x2F; bat  ls -a&#x2F;-Arfalias   &#x2F;&#x2F; 别名apt &#x2F; snap &#x2F; yum   &#x2F;&#x2F; 包管理find查找&#x2F; -name file1从&#39;&#x2F;&#39;开始进入根目录文件系统搜索文件和目录&#x2F; -user user1搜索属于用户&#39;user1&#39;的文件和目录&#x2F;home -name \*bin在&#x2F;home下搜索以bin结尾的文件&#x2F;home -type f -atime +100 搜索在过去100天内未被使用过的文件mount&#x2F;dev&#x2F;hda2 &#x2F;mnt&#x2F;hda2 挂载一个叫做hda2的盘 &#x2F;mnt&#x2F;hda2 已存在umount &#x2F;dev&#x2F;hda2 卸载一个叫做hda2的盘(先从)update - 从服务器更新可用的软件包列表。upgrade - 根据列表，更新已安装的软件包。upgrade 不会删除在列表中已经没有的软件包，也不会安装有依赖需求但尚未安装的软件包。full-upgrade - 根据列表，更新已安装的软件包。full-upgrade 可能会为了解决软件包冲突而删除一些已安装的软件包。dist-upgrade - 根据列表，更新已安装的软件包。dist-upgrade 可能会为了解决软件包冲突而删除一些已安装的软件包，也可能会为了解决软件包依赖问题安装新的软件包。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><p>安装openssh-server, 可在windows下用Xshell等工具连接</p><p>lrzsz 用于传输文件</p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="xshell-使用-Oh-My-ZSH-home键-end键-小键盘区无效解决办法"><a href="#xshell-使用-Oh-My-ZSH-home键-end键-小键盘区无效解决办法" class="headerlink" title="xshell 使用 Oh My ZSH home键 end键 小键盘区无效解决办法"></a>xshell 使用 Oh My ZSH home键 end键 小键盘区无效解决办法</h3><p><a href="https://anjia0532.github.io/2017/09/10/zsh-home-end-keypad-not-work/">2017-09-10</a></p><p>zsh是一款超赞的shell工具，但是配置复杂，有个闲着没事的程序员，弄了一个开源项目 <a href="https://github.com/robbyrussell/oh-my-zsh">robbyrussell/oh-my-zsh</a> 截止目前，58.8k+ star就知道有多火了。比如 Spring boot在github才 15.7K+ spring framework 也16.1k+,最近火到炸天的tensorflow 69.4k</p><p>同样很优秀的有 <a href="https://github.com/fisherman/fisherman">fisherman/fisherman</a></p><p>此文不讲如何安装，如何配置 。有此需求的同学，出门左转，找度娘解决。</p><p>此文主要解决，xshell 远程连接时，host将zsh设置成默认shell时，Home,End,小键盘区诸键无效问题</p><p>参考连接 <a href="https://github.com/robbyrussell/oh-my-zsh/issues/3061#issuecomment-93494905">Cannot using home/end key after install oh-my-zsh</a></p><p>第一种方法也是最简单的办法是，修改xshell连接此host的终端类型，改成<code>linux</code><br><img src="http://ww1.sinaimg.cn/large/afaffa71ly1fjekq3ap0wj20fu0d3jrt.jpg" class="lazyload" data-srcset="http://ww1.sinaimg.cn/large/afaffa71ly1fjekq3ap0wj20fu0d3jrt.jpg" srcset="data:image/png;base64,666" alt="img"></p><p>但是注意 <a href="https://github.com/linlinlinlin">@linlinlinlin </a>所说，改用<code>linux</code>可能会导致shell的颜色比较奇怪。</p><p><code>linux</code><img src="http://ww1.sinaimg.cn/large/afaffa71ly1fjel9lc8faj205706rglk.jpg" class="lazyload" data-srcset="http://ww1.sinaimg.cn/large/afaffa71ly1fjel9lc8faj205706rglk.jpg" srcset="data:image/png;base64,666" alt="img"><code>xterm</code><img src="http://ww1.sinaimg.cn/large/afaffa71ly1fjel9lchsfj207e09gaa4.jpg" class="lazyload" data-srcset="http://ww1.sinaimg.cn/large/afaffa71ly1fjel9lchsfj207e09gaa4.jpg" srcset="data:image/png;base64,666" alt="img"></p><p>结合 <a href="https://github.com/candrew34">@candrew34</a> 和 <a href="https://github.com/linlinlinlin">@linlinlinlin </a>的回复，得出第二种方案</p><p>第二种方法，稍微复杂点</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat &lt;&lt;ENDOF &gt;&gt; ~&#x2F;.zshrc# Homebindkey &#39;\e[1~&#39; beginning-of-line# Endbindkey &#39;\e[4~&#39; end-of-line# Keypad# 0 . Enterbindkey -s &quot;^[Op&quot; &quot;0&quot;bindkey -s &quot;^[Ol&quot; &quot;.&quot;bindkey -s &quot;^[OM&quot; &quot;^M&quot;# 1 2 3bindkey -s &quot;^[Oq&quot; &quot;1&quot;bindkey -s &quot;^[Or&quot; &quot;2&quot;bindkey -s &quot;^[Os&quot; &quot;3&quot;# 4 5 6bindkey -s &quot;^[Ot&quot; &quot;4&quot;bindkey -s &quot;^[Ou&quot; &quot;5&quot;bindkey -s &quot;^[Ov&quot; &quot;6&quot;# 7 8 9bindkey -s &quot;^[Ow&quot; &quot;7&quot;bindkey -s &quot;^[Ox&quot; &quot;8&quot;bindkey -s &quot;^[Oy&quot; &quot;9&quot;# + -  * &#x2F;bindkey -s &quot;^[Ok&quot; &quot;+&quot;bindkey -s &quot;^[Om&quot; &quot;-&quot;bindkey -s &quot;^[Oj&quot; &quot;*&quot;bindkey -s &quot;^[Oo&quot; &quot;&#x2F;&quot;ENDOFsource ~&#x2F;.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另附 <a href="http://blog.csdn.net/jiedushi/article/details/6266944">客户端putty, xshell连接linux中vim的小键盘问题</a></p><h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><h2 id="Ubuntu18-04安装MySQL8-0"><a href="#Ubuntu18-04安装MySQL8-0" class="headerlink" title="Ubuntu18.04安装MySQL8.0"></a>Ubuntu18.04安装MySQL8.0</h2><p>为什么要做这个呢？因为不知道为什么我Ubuntu18.04 安装MySQL5.7 之后，终端不能输入中文。网上的方法试了个遍。无论是各种改utf8，还是系统字符集更改，还是添加字符集，等等，都不行。无奈，只好卸载5.7，装上最新的MySQL8.0. 装完之后立马就可以输入中文，开心。嘿嘿！  </p><p>首先删除mysql:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get remove mysql-*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 然后清理残留的数据</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">dpkg -l |grep ^rc|awk &#39;&#123;print $2&#125;&#39; |sudo xargs dpkg -P<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>它会跳出一个对话框，你选择yes就好了</p><p>然后就是安装了，但是呢，<strong>不能用</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get install mysql-client mysql-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>为什么呢？因为这时候安装的还是5.7.阅读了一下MySQL安装指南，发现MySQL5.7版本最高只适配到Ubuntu17.04，而MySQL8.0最高适配到Ubuntu18.04。</p><p>那怎么办呢？ 官网去整一个答案回来. 如下：</p><p>首先要去<a href="http://dev.mysql.com/downloads/repo/apt/">官网</a> 下载一个 mysql-apt-config_0..***_all.deb，</p><p>在文件夹中找到下载的具体文件，并执行（下面的 * <strong>是省略的意思，你自己要改）</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo dpkg -i mysql-apt-config_0.*.****_all.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装执行, 然后会出现一个紫色框界面.  它有四个选项。选择第一个, enter确定, 然后又会出现一个紫色框界面, 选择8.0那个。enter确定， 会回到第一个紫色框，此时按上下键选择 ok，enter确定。</p><p>之后执行</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt-get updatesudo apt-get install mysql-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装过程中会询问，都选择yes. 安装最后会出现紫色框，让你输入密码，输入完成之后，会再让你输入一遍。确定. 输入完成之后，会出现紫色框问你选择密码的加密方式。因为第一种加密方式Ubuntu不支持，所以我们选择第二个加密方式。enter确定。</p><p>此时启动MySQL：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">service mysql start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入MySQL: </p><pre class="line-numbers language-none"><code class="language-none">mysql -uroot -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入中文测试，成功！</p><p>参考：<br>    <a href="https://www.jianshu.com/p/c76b31df5d09">https://www.jianshu.com/p/c76b31df5d09</a><br>    <a href="https://jingyan.baidu.com/article/fdbd4277bb981ab89e3f4897.html">https://jingyan.baidu.com/article/fdbd4277bb981ab89e3f4897.html</a><br>    <a href="https://blog.csdn.net/weixin_37946237/article/details/81634505">https://blog.csdn.net/weixin_37946237/article/details/81634505</a></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li><p>连接MySQL时报错:</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;&#x2F;tmp&#x2F;mysql.sock&#39; (2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  <strong>解决办法:</strong></p><p>  我的第一个建议是检查MySQL服务器是否正在运行。第二个建议可能是，MySQL服务器是否在另一个主机上运行？如果是，则添加<code>-h </code>标记到终端中的MySQL客户端。</p><p>  如果MySQL确实在运行，并且在本地运行，请检查<code>my.cnf</code>档案。应该有这样一条线</p>  <pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">socket <span class="token operator">=</span> <span class="token operator">/</span><span class="token keyword">var</span><span class="token operator">/</span>run<span class="token operator">/</span>mysqld<span class="token operator">/</span>mysqld<span class="token punctuation">.</span>sock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  看看这是否与您在文章中提到的套接字位置相匹配。</p><p>  根据经验，我认为最有可能的情况是MySQL服务器要么根本没有运行，要么没有在与从终端运行MySQL客户端的主机相同的主机上运行。</p></li><li><p>无法远程连接</p><p>  从MySQL 8开始，您不再可以（隐式）使用<code>GRANT</code>命令创建用户。请改用<a href="https://dev.mysql.com/doc/refman/8.0/en/create-user.html">CREATE USER</a>，然后使用<a href="https://dev.mysql.com/doc/refman/8.0/en/grant.html">GRANT</a>语句：</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">></span> <span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">'root'</span><span class="token variable">@'%'</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">'root'</span><span class="token punctuation">;</span>mysql<span class="token operator">></span> <span class="token keyword">GRANT</span> <span class="token keyword">ALL</span> <span class="token keyword">PRIVILEGES</span> <span class="token keyword">ON</span> <span class="token operator">*</span><span class="token punctuation">.</span><span class="token operator">*</span> <span class="token keyword">TO</span> <span class="token string">'root'</span><span class="token variable">@'%'</span> <span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="tomcat安装"><a href="#tomcat安装" class="headerlink" title="tomcat安装"></a>tomcat安装</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Apache Tomcat是一个Web服务器和servlet容器，用于为Java应用程序提供服务。 Tomcat是Apache Software Foundation发布的Java Servlet和JavaServer Pages技术的开源实现。 本教程介绍了Ubuntu 18.04服务器上最新版Tomcat 9的基本安装和一些配置。</p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>在开始本指南之前，您应该拥有一个在您的服务器上设置了<code>sudo</code>权限的非root用户。 您可以通过完成我们的<a href="https://www.howtoing.com/initial-server-setup-with-ubuntu-16-04/">Ubuntu 16.04初始服务器设置指南</a>来了解如何执行此操作。</p><h3 id="第1步-安装Java"><a href="#第1步-安装Java" class="headerlink" title="第1步-安装Java"></a>第1步-安装Java</h3><p>Tomcat要求在服务器上安装Java，以便可以执行任何Java Web应用程序代码。 我们可以通过apt安装OpenJDK来满足这个要求。</p><p>首先，更新你的apt包索引：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt update<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后使用apt安装Java Development Kit软件包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo apt install default-jdk<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在已经安装了Java，我们可以创建一个<code>tomcat</code>用户，该用户将用于运行Tomcat服务。</p><h3 id="第2步-创建Tomcat用户"><a href="#第2步-创建Tomcat用户" class="headerlink" title="第2步-创建Tomcat用户"></a>第2步-创建Tomcat用户</h3><p>出于安全考虑，Tomcat应该作为非特权用户运行（即不是root用户）。 我们将创建一个将运行Tomcat服务的新用户和组。</p><p>首先，创建一个新的<code>tomcat</code>组：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo groupadd tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，创建一个新的<code>tomcat</code>用户。 我们将使这个用户成为<code>tomcat</code>组的成员，主目录为<code>/opt/tomcat</code> （我们将安装Tomcat），shell为<code>/bin/false</code> （因此没有人可以登录该帐户）：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo useradd -s &#x2F;bin&#x2F;false -g tomcat -d &#x2F;opt&#x2F;tomcat tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在我们已经设置了<code>tomcat</code>用户，让我们下载并安装Tomcat。</p><h3 id="第3步-安装Tomcat"><a href="#第3步-安装Tomcat" class="headerlink" title="第3步-安装Tomcat"></a>第3步-安装Tomcat</h3><p>安装Tomcat 9的最佳方法是下载最新的二进制版本，然后手动配置它。</p><p>在<a href="https://tomcat.apache.org/download-90.cgi">Tomcat 9下载页面上</a>找到最新版本的Tomcat 9。 在撰写本文时，最新版本为<strong>9.0.10</strong> ，但如果可用，则应使用更高版本的稳定版本。 在<strong>Binary Distributions</strong>部分下，然后在<strong>Core</strong>列表下，将链接复制到“tar.gz”。</p><p>接下来，切换到服务器上的<code>/tmp</code>目录。 这是一个很好的下载短暂项目的目录，比如Tomcat tarball，在提取Tomcat内容后我们不需要这样：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd &#x2F;tmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用<code>curl</code>下载从Tomcat网站复制的链接：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">curl -O http:&#x2F;&#x2F;mirror.cc.columbia.edu&#x2F;pub&#x2F;software&#x2F;apache&#x2F;tomcat&#x2F;tomcat-9&#x2F;v9.0.10&#x2F;bin&#x2F;apache-tomcat-9.0.10.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们将Tomcat安装到<code>/opt/tomcat</code>目录。 创建目录，然后使用以下命令将存档解压缩到它：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo mkdir &#x2F;opt&#x2F;tomcatsudo tar xzvf apache-tomcat-9*tar.gz -C &#x2F;opt&#x2F;tomcat --strip-components&#x3D;1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>接下来，我们可以为我们的安装设置适当的用户权限。</p><h3 id="第4步-更新权限"><a href="#第4步-更新权限" class="headerlink" title="第4步 - 更新权限"></a>第4步 - 更新权限</h3><p>我们设置的<code>tomcat</code>用户需要能够访问Tomcat安装。 我们现在就把它搞定。</p><p>切换到我们解压缩Tomcat安装的目录：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd &#x2F;opt&#x2F;tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>授予<code>tomcat</code>组对整个安装目录的所有权：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo chgrp -R tomcat &#x2F;opt&#x2F;tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>接下来，让<code>tomcat</code>组对<code>conf</code>目录及其所有内容进行读访问，并<strong>执行</strong>对目录本身的访问：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo chmod -R g+r confsudo chmod g+x conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>使<code>tomcat</code>用户成为<code>webapps</code> ， <code>work</code> ， <code>temp</code>和<code>logs</code>目录的所有者：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo chown -R tomcat webapps&#x2F; work&#x2F; temp&#x2F; logs&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在已经设置了适当的权限，我们可以创建一个systemd服务文件来管理Tomcat进程。</p><h3 id="第5步-创建systemd服务文件"><a href="#第5步-创建systemd服务文件" class="headerlink" title="第5步 - 创建systemd服务文件"></a>第5步 - 创建systemd服务文件</h3><p>我们希望能够将Tomcat作为服务运行，因此我们将设置systemd服务文件。</p><p>Tomcat需要知道Java的安装位置。 此路径通常称为“JAVA_HOME”。 查找该位置的最简单方法是运行此命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo update-java-alternatives -lOutputjava-1.11.0-openjdk-amd64       1081       &#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.11.0-openjdk-amd64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>您的<code>JAVA_HOME</code>是最后一列的输出（以红色突出显示）。 鉴于上面的示例，此服务器的正确<code>JAVA_HOME</code>将是：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">JAVA_HOME&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.11.0-openjdk-amd64<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你的<code>JAVA_HOME</code>可能会有所不同。</p><p>有了这条信息，我们就可以创建systemd服务文件了。 键入以下命令，在<code>/etc/systemd/system</code>目录中打开名为<code>tomcat.service</code>的文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo nano &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;tomcat.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将以下内容粘贴到您的服务文件中。 如有必要，修改<code>JAVA_HOME</code>的值以匹配您在系统上找到的值。 您可能还想修改<code>CATALINA_OPTS</code>中指定的内存分配设置：</p><p>/etc/systemd/system/tomcat.service</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[Unit]Description&#x3D;Apache Tomcat Web Application ContainerAfter&#x3D;network.target[Service]Type&#x3D;forkingEnvironment&#x3D;JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.11.0-openjdk-amd64Environment&#x3D;CATALINA_PID&#x3D;&#x2F;opt&#x2F;tomcat&#x2F;temp&#x2F;tomcat.pidEnvironment&#x3D;CATALINA_HOME&#x3D;&#x2F;opt&#x2F;tomcatEnvironment&#x3D;CATALINA_BASE&#x3D;&#x2F;opt&#x2F;tomcatEnvironment&#x3D;&#39;CATALINA_OPTS&#x3D;-Xms512M -Xmx1024M -server -XX:+UseParallelGC&#39;Environment&#x3D;&#39;JAVA_OPTS&#x3D;-Djava.awt.headless&#x3D;true -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&#39;ExecStart&#x3D;&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;startup.shExecStop&#x3D;&#x2F;opt&#x2F;tomcat&#x2F;bin&#x2F;shutdown.shUser&#x3D;tomcatGroup&#x3D;tomcatUMask&#x3D;0007RestartSec&#x3D;10Restart&#x3D;always[Install]WantedBy&#x3D;multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>完成后，保存并关闭文件。</p><p>接下来，重新加载systemd守护程序，以便它知道我们的服务文件：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>键入以下命令启动Tomcat服务：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo systemctl start tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>键入以下内容，仔细检查它是否正常启动：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo systemctl status tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第6步-调整防火墙并测试Tomcat服务器"><a href="#第6步-调整防火墙并测试Tomcat服务器" class="headerlink" title="第6步 - 调整防火墙并测试Tomcat服务器"></a>第6步 - 调整防火墙并测试Tomcat服务器</h3><p>现在Tomcat服务已启动，我们可以测试以确保默认页面可用。</p><p>在我们这样做之前，我们需要调整防火墙以允许我们的请求到达服务。 如果您遵循先决条件，则当前将启用<code>ufw</code>防火墙。</p><p>Tomcat使用端口<code>8080</code>接受传统请求。 输入以下内容允许到该端口的流量：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo ufw allow 8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改防火墙后，您可以通过在Web浏览器中访问您的域或IP地址，然后访问<code>:8080</code>来访问默认启动页面：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Open in web browserhttp:&#x2F;&#x2F;server_domain_or_IP:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>除了其他信息之外，您还将看到默认的Tomcat启动页面。 但是，例如，如果单击Manager App的链接，则将拒绝您访问。 我们接下来可以配置该访问。</p><p>如果您能够成功访问Tomcat，现在是启用服务文件的好时机，以便Tomcat在启动时自动启动：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo systemctl enable tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第7步-配置Tomcat-Web管理界面"><a href="#第7步-配置Tomcat-Web管理界面" class="headerlink" title="第7步-配置Tomcat Web管理界面"></a>第7步-配置Tomcat Web管理界面</h3><p>为了使用Tomcat附带的管理器Web应用程序，我们必须向Tomcat服务器添加登录。 我们将通过编辑<code>tomcat-users.xml</code>文件来完成此操作：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo nano &#x2F;opt&#x2F;tomcat&#x2F;conf&#x2F;tomcat-users.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您将需要添加可以访问<code>manager-gui</code>和<code>admin-gui</code> （Tomcat附带的Web应用程序）的用户。 您可以通过在<code>tomcat-users</code>标记之间定义类似于下面示例<code>tomcat-users</code>目的。 请务必将用户名和密码更改为安全的内容：</p><p>tomcat-users.xml - 管理员用户</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;tomcat-users . . .&gt;    &lt;user username&#x3D;&quot;admin&quot; password&#x3D;&quot;password&quot; roles&#x3D;&quot;manager-gui,admin-gui&quot;&#x2F;&gt;&lt;&#x2F;tomcat-users&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>完成后保存并关闭文件。</p><p>默认情况下，较新版本的Tomcat将对Manager和Host Manager应用程序的访问限制为来自服务器本身的连接。 由于我们在远程计算机上安装，您可能希望删除或更改此限制。 要更改对这些的IP地址限制，请打开相应的<code>context.xml</code>文件。</p><p>对于Manager应用，请键入：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo nano &#x2F;opt&#x2F;tomcat&#x2F;webapps&#x2F;manager&#x2F;META-INF&#x2F;context.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于Host Manager应用程序，请键入：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sudo nano &#x2F;opt&#x2F;tomcat&#x2F;webapps&#x2F;host-manager&#x2F;META-INF&#x2F;context.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在内部，注释掉IP地址限制以允许来自任何地方的连接。 或者，如果您只允许访问来自您自己的IP地址的连接，您可以将您的公共IP地址添加到列表中：</p><p>Tomcat webapps的context.xml文件</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&lt;Context antiResourceLocking&#x3D;&quot;false&quot; privileged&#x3D;&quot;true&quot; &gt;  &lt;!--&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.RemoteAddrValve&quot;         allow&#x3D;&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; &#x2F;&gt;--&gt;&lt;&#x2F;Context&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完成后保存并关闭文件。</p><p>要使我们的更改生效，请重新启动Tomcat服务：</p><pre class="line-numbers language-none"><code class="language-none">sudo systemctl restart tomcat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="第8步-访问Web界面"><a href="#第8步-访问Web界面" class="headerlink" title="第8步-访问Web界面"></a>第8步-访问Web界面</h3><p>现在我们已经创建了一个用户，我们可以在Web浏览器中再次访问Web管理界面。 再一次，您可以通过在浏览器中输入端口8080后面的服务器域名或IP地址来访问正确的界面：</p><pre class="line-numbers language-none"><code class="language-none">Open in web browserhttp:&#x2F;&#x2F;server_domain_or_IP:8080<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>您看到的页面应该与您之前测试时给出的页面相同：</p><p><img src=".static/imgs/Linux/splashscreen.png" class="lazyload" data-srcset=".static/imgs/Linux/splashscreen.png" srcset="data:image/png;base64,666" alt="Tomcat root"></p><p>我们来看看Manager App，可以通过链接或<code>http:// server_domain_or_IP :8080/manager/html</code> 。 您需要输入添加到<code>tomcat-users.xml</code>文件的帐户凭据。 之后，您应该看到如下所示的页面：</p><p><img src=".static/imgs/Linux/manager.png" class="lazyload" data-srcset=".static/imgs/Linux/manager.png" srcset="data:image/png;base64,666" alt="Tomcat Web应用程序管理器"></p><p>Web应用程序管理器用于管理Java应用程序。 您可以在此处启动，停止，重新加载，部署和取消部署。 您还可以在应用程序上运行一些诊断程序（即查找内存泄漏）。 最后，本页最下方提供了有关您的服务器的信息。</p><p>现在让我们看看主机管理器，可以通过链接或<code>http:// server_domain_or_IP :8080/host-manager/html/</code> ：</p><p><img src=".static/imgs/Linux/host-manager.png" class="lazyload" data-srcset=".static/imgs/Linux/host-manager.png" srcset="data:image/png;base64,666" alt="Tomcat虚拟主机管理器"></p><p>在Virtual Host Manager页面中，您可以添加虚拟主机以便为您的应用程序提供服务。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>你的Tomcat安装完成了！ 您现在可以自由部署自己的Java Web应用程序了！</p><p>目前，您的Tomcat安装功能正常，但完全未加密。 这意味着所有数据（包括密码等敏感项目）都以纯文本形式发送，可以被互联网上的其他方拦截和阅读。 为了防止这种情况发生，强烈建议您使用SSL加密连接。 您可以按照<a href="https://www.howtoing.com/how-to-encrypt-tomcat-8-connections-with-apache-or-nginx-on-ubuntu-16-04/">本指南</a>了解如何加密与Tomcat的连接（ <em>注意：本指南介绍了Ubuntu 16.04上的Tomcat 8加密</em> ）。</p><h1 id="Manjaro"><a href="#Manjaro" class="headerlink" title="Manjaro"></a>Manjaro</h1><h2 id="Linux系统Manjaro分辨率调整恢复"><a href="#Linux系统Manjaro分辨率调整恢复" class="headerlink" title="Linux系统Manjaro分辨率调整恢复"></a><strong>Linux系统Manjaro分辨率调整恢复</strong></h2><h3 id="意外情况"><a href="#意外情况" class="headerlink" title="意外情况"></a>意外情况</h3><p>近期将一台六年前的老笔记本换成了Manjaro系统，今晚外接显示器时突然原笔记本电脑屏幕的分辨率降低，并且在系统设置页面中丢失了原有的1380×760分辨率，最大只有960×540的分辨率。</p><h3 id="问题解决-通过命令行添加自定义分辨率"><a href="#问题解决-通过命令行添加自定义分辨率" class="headerlink" title="问题解决-通过命令行添加自定义分辨率"></a>问题解决-通过命令行添加自定义分辨率</h3><p>既然是linux系统，设置有关的内容一定可以用命令行解决。系统设置丢失了分辨率模式，自己手动加上去就行了。</p><p>首先用管理员权限，查看当前显示器的分辨模式</p><pre class="line-numbers language-none"><code class="language-none">sudo xrandr -q[parrysms@parrysms-pc ~]$ sudo xrandr -qScreen 0: minimum 8 x 8, current  960x540, maximum 32767 x 32767LVDS1 connected primary  960x540+0+0 (normal left inverted right x axis y axis) 310mm x 170mm   960x540       59.82     864x486       60.00    59.92    59.57     640x480       59.94  DP1 disconnected (normal left inverted right x axis y axis)HDMI1 disconnected (normal left inverted right x axis y axis)VGA1 disconnected (normal left inverted right x axis y axis)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令行会显示系统里有的分辨率。如果没有你显示器对应的分辨率，那么就需要自行添加，添加的第一步是使用<code>cvt</code>设置自定义分辨率。注意这里<code>cvt</code>命令后面两个的分辨率参数一定得是小于等于显示器最大支持的分辨率。</p><pre class="line-numbers language-none"><code class="language-none">sudo cvt 1360 768[parrysms@parrysms-pc ~]$ cvt 1360 768# 1360x768 59.80 Hz (CVT) hsync: 47.72 kHz; pclk: 84.75 MHzModeline &quot;1360x768_60.00&quot;   84.75  1360 1432 1568 1776  768 771 781 798 -hsync +vsync<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此时将会显示两行信息，找到 <code>Modeline &quot;1360x768_60.00&quot;</code> 的这个部分。Modeline 后面的 “1380x760_60.00” 部分是这个分辨率的模式及的名字，从引号开始到最后全部选中复制下来。（命令行里鼠标右键有复制选项）</p><p>使用参数新增分辨率模式，指令如下：<br><code>xrandr --newmode 加上Modeline 后面的分辨率模式名以及一连串数字</code></p><p>举例而言，我的指令是<br><code>sudo xrandr --newmode &quot;1360x768_60.00&quot; 84.75 1360 1432 1568 1776 768 771 781 798 -hsync +vsync</code></p><p>最后，需要将新的自定义分辨率模式，添加到指定的显示器配置中，显示器名字就是最开始<code>sudo xrandr -q</code> 命令中看到有分辨率模式的那个显示器。如果不想往上翻可以重新敲命令查一次。</p><pre class="line-numbers language-none"><code class="language-none">[parrysms@parrysms-pc ~]$ sudo xrandr -qScreen 0: minimum 8 x 8, current  960x540 maximum 32767 x 32767LVDS1 connected primary  960x540+0+0 (normal left inverted right x axis y axis) 310mm x 170mm   960x540       59.82     864x486       60.00    59.92    59.57     640x480       59.94  DP1 disconnected (normal left inverted right x axis y axis)HDMI1 disconnected (normal left inverted right x axis y axis)VGA1 disconnected (normal left inverted right x axis y axis)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里可以看到笔记本自带的显示器名字是 <code>LVDS1</code>，所以使用<code>addmode</code>指令来添加。指令如下：</p><pre class="line-numbers language-none"><code class="language-none">sudo xrandr --addmode 显示器名 分辨率模式名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此我的指令是 （注意引号）：<br><code>sudo xrandr --addmode LVDS1 &quot;1360x768_60.00&quot;</code></p><p>最后一步，output 输出使其配置生效即可。指令如下：</p><pre class="line-numbers language-none"><code class="language-none">sudo xrandr --output 显示器名 --mode 分辨率模式名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因此我的指令是 （注意引号）：<br><code>sudo xrandr --output LVDS1 --mode &quot;1360x768_60.00&quot;</code></p><p>最后敲下回车，随着屏幕一闪，自定义分辨率就生效了。</p><h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><h2 id="shell-计算机壳层"><a href="#shell-计算机壳层" class="headerlink" title="shell (计算机壳层)"></a>shell (计算机壳层)</h2><p>在计算机科学中，Shell俗称壳（用来区别于核），是指“为使用者提供操作界面”的软件（命令解析器）。它类似于<a href="https://baike.baidu.com/item/DOS">DOS</a>下的command.com和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。</p><p><strong>基本上shell分两大类：</strong></p><p><strong>一：图形界面shell（Graphical User Interface shell 即 GUI shell）</strong></p><p>例如：应用最为广泛的 Windows Explorer （微软的windows系列操作系统），还有也包括广为人知的 Linux shell，其中<a href="https://baike.baidu.com/item/linux">linux</a> shell 包括 X window manager (BlackBox和FluxBox），以及功能更强大的CDE、GNOME、KDE、 XFCE。</p><p><strong>二：命令行式shell（Command Line Interface shell ，即CLI shell）</strong></p><p>例如：</p><p>bash / sh / ksh / csh / zsh（Unix/linux 系统）</p><p>（<a href="https://baike.baidu.com/item/MS-DOS">MS-DOS</a>系统）</p><p><a href="https://baike.baidu.com/item/cmd.exe">cmd.exe</a>/ 命令提示字符（[Windows NT](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> NT) 系统）</p><p>Windows PowerShell（支持 .NET Framework 技术的 Windows NT 系统）</p><p>传统意义上的shell指的是命令行式的shell，以后如果不特别注明，shell是指命令行式的shell。</p><p>文字操作系统与外部最主要的接口就叫做shell。shell是操作系统最外面的一层。shell管理你与操作系统之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。</p><p>shell提供了你与操作系统之间通讯的方式。这种通讯可以以交互方式（从键盘输入，并且可以立即得到响应），或者以shell script(非交互）方式执行。shell script是放在文件中的一串shell和操作系统命令，它们可以被重复使用。本质上，shell script是命令行命令简单的组合到一个文件里面。</p><p>Shell基本上是一个命令<a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>，类似于<a href="https://baike.baidu.com/item/DOS">DOS</a>下的command。它接收用户命令（如ls等），然后调用相应的应用程序。较为通用的shell有标准的Bourne shell (sh）和C shell (csh）。</p><p>交互式shell和非交互式shell</p><p>交互式模式就是shell等待你的输入，并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。这种模式也是大多数用户非常熟悉的：登录、执行一些命令、签退。当你签退后，shell也终止了。</p><p>shell也可以运行在另外一种模式：非交互式模式。在这种模式下，shell不与你进行交互，而是读取存放在文件中的命令，并且执行它们。当它读到文件的结尾，shell也就终止了。</p><p>shell的类型</p><p>在<a href="https://baike.baidu.com/item/UNIX">UNIX</a>中主要有：</p><p>Bourne shell （包括 sh,ksh,and bash)</p><p>Bourne shell ( sh)</p><p>Korn shell ( ksh)</p><p>Bourne Again shell ( bash)</p><p>POSIX shell ( sh)</p><p>C shell （包括 csh and tcsh)</p><p>C shell ( csh)</p><p>TENEX/TOPS C shell ( tcsh)</p><p><strong>Bourne Shell</strong></p><p>**<br>**　　</p><p>首个重要的标准Unix Shell是1979年底在V7 Unix(AT&amp;T第7版）中引入的，并且以它的创始科技部基础条件平台“国家气象网络计算应用节点建设”（2004DKA50730）资助者Stephen Bourne的名字命名。Bourne shell 是一个交换式的命令<a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%99%A8">解释器</a>和命令编程语言。Bourne shell 可以运行为login shell或者login shell的子shell(subshell）。只有login命令可以调用Bourne shell作为一个login shell。此时，shell先读取/etc/profile文件和$HOME/.profile文件。/etc/profile文件为所有的用户定制环境，$HOME/.profile文件为本用户定制环境。最后，shell会等待读取你的输入。</p><p><strong>C Shell</strong></p><p>Bill Joy于20世纪80年代早期，在伯克利的<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%88%A9%E7%A6%8F%E5%B0%BC%E4%BA%9A%E5%A4%A7%E5%AD%A6">加利福尼亚大学</a>开发了C shell。它主要是为了让用户更容易的使用交互式功能，并把ALGOL风格的语法结构变成了C语言风格。它新增了命令历史、别名、文件名替换、<a href="https://baike.baidu.com/item/%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6">作业控制</a>等功能。</p><p><strong>Korn Shell</strong></p><p>有很长一段时间，只有两类shell供人们选择，Bourne shell用来编程，C shell用来交互。为了改变这种状况，AT&amp;T的bell实验室David Korn开发了Korn shell。ksh结合了所有的C shell的交互式特性，并融入了Bourne shell的语法。因此，Korn shell广受用户的欢迎。它还新增了数学计算，进程协作（coprocess）、行内编辑（inline editing）等功能。Korn Shell 是一个交互式的命令解释器和命令编程语言.它符合POSIX——一个操作系统的国际标准.POSIX不是一个操作系统，而是一个目标在于应用程序的移植性的标准——在<a href="https://baike.baidu.com/item/%E6%BA%90%E7%A8%8B%E5%BA%8F">源程序</a>一级跨越多种平台。</p><p><strong>Bourne Again Shell (bash)</strong></p><p>bash是<a href="https://baike.baidu.com/item/GNU">GNU</a>计划的一部分，用来替代Bourne shell。它用于基于GNU的系统如Linux.大多数的Linux(Red Hat,Slackware,Caldera）都以bash作为缺省的shell，并且运行sh时，其实调用的是bash。</p><p><strong>POSIX Shell</strong></p><p>POSIX shell 是Korn shell的一个变种. 当前提供POSIX shell的最大卖主是<a href="https://baike.baidu.com/item/Hewlett-Packard">Hewlett-Packard</a>。在HP-UX 11.0,POSIX shell 就是/bin/sh，而<a href="https://baike.baidu.com/item/bsh">bsh</a>是/usr/old/bin/sh.</p><p>各主要操作系统下缺省的shell:</p><p><a href="https://baike.baidu.com/item/AIX">AIX</a>下是Korn Shell.</p><p><a href="https://baike.baidu.com/item/Solaris">Solaris</a>缺省的是Bourne shell.</p><p><a href="https://baike.baidu.com/item/FreeBSD">FreeBSD</a>缺省的是C shell</p><p><a href="https://baike.baidu.com/item/HP-UX">HP-UX</a>缺省的是POSIX shell.</p><p><a href="https://baike.baidu.com/item/Linux">Linux</a>是Bourne Again shell.</p><p>[Windows PowerShell](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> PowerShell)是一种新的交互式的命令行和基于任务脚本编写技术，它使信息技术(IT) 管理员能够全面地自动操作和控制系统管理任务，从而提高了管理员的生产力。Windows PowerShell 包括多个系统管理实用工具、一致的语法和命名惯例、及对普通管理数据更好地导航，如登记、证书存储 或 Windows Management Instrumentation (WMI）。Windows PowerShell 还专门针对 IT 管理，提供直观的<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99">脚本编写</a>语言。</p><p>Shell也是一个VB函数，它的作用是运行程序，语法是Shell（命令字符串[，窗口类型])</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>使用用户的缺省凭证和环境执行 shell。</p><p>在UEFI环境下，EFI的Shell环境提供了一组丰富的扩展和增强的命令，在以后的计算机中，传统的DOS界面将会被SHELL环境所取代，所有的.exe文件将不会在以后支持SHELL的环境中出现，取而代之的文件后缀是.efi。在SHELL环境下，分为IA32和X64，32位的*.efi文件不能在X64的计算机中运行。</p><ol><li>相对于其他系统，Mac 的主要优势是什么？</li><li>你们平时用哪种 Shell？<br> ……</li></ol><p>第一个童靴可以坐下了，Mac 的最大优势是 GUI 和命令行的完美结合，不要把所有注意力放在 Mac 性感的腰身和明媚的显示屏上好吧，这不是妹纸！第二个童靴你可以出去面壁了，讲了这么多期 MacTalk 你告诉我还在用 Windows 的 cmd， 你让 Mac 君情何以堪？哪怕你就说在用 Linux 的 Bash 我也就原谅你了，踢飞！</p><p>上次在「如何学习一门编程语言」里提到了 Shell，也有读者问到 Shell 的问题，所以这次给大家说说 Shell 的事。</p><p>我在「趣谈个人建站」里介绍过一点 Shell，自己的东西借用下不丢人，把扯淡的拿掉，干货留下，就是如下内容：</p><p>Shell是Linux/Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。</p><p>Linux/Unix提供了很多种Shell，为毛要这么多Shell？难道用来炒着吃么？那我问你，你同类型的衣服怎么有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员往往负责把复杂的事情搞简单，简单的事情搞复杂。牛程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等，想知道你的系统有几种shell，可以通过以下命令查看：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat &#x2F;etc&#x2F;shells<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>显示如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">&#x2F;bin&#x2F;bash&#x2F;bin&#x2F;csh&#x2F;bin&#x2F;ksh&#x2F;bin&#x2F;sh&#x2F;bin&#x2F;tcsh&#x2F;bin&#x2F;zsh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，这是个神马 Shell 呢？</p><p>目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」，Github 网址是：<a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh">https://github.com/robbyrussell/oh-my-zsh</a>。这玩意就像「X天叫你学会 C++」系列，可以让你神功速成，而且是真的。</p><p>好，下面我们看看如何安装、配置和使用 zsh。</p><p><strong>安装zsh</strong></p><p>如果你用 Mac，就可以直接看下一节<br>如果你用 Redhat Linux，执行：sudo yum install zsh<br>如果你用 Ubuntu Linux，执行：sudo apt-get install zsh<br>如果你用 Windows……去洗洗睡吧。</p><p>安装完成后设置当前用户使用 zsh：chsh -s /bin/zsh，根据提示输入当前用户的密码就可以了。</p><p>安装oh my zsh</p><p>首先安装 git，安装方式同上，把 zsh 换成 git 即可。</p><p>安装「oh my zsh」可以自动安装也可以手动安装。</p><p>自动安装：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">wget https:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh&#x2F;raw&#x2F;master&#x2F;tools&#x2F;install.sh -O - | sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>手动安装：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">git clone git:&#x2F;&#x2F;github.com&#x2F;robbyrussell&#x2F;oh-my-zsh.git ~&#x2F;.oh-my-zshcp ~&#x2F;.oh-my-zsh&#x2F;templates&#x2F;zshrc.zsh-template ~&#x2F;.zshrc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到这个彩色的提示了：</p><p><img src="../../%25E7%25AC%2594%25E8%25AE%25B0/%25E8%25AE%25B0%25E4%25BA%258B%25E6%259C%25AC/static/Linux.access/6bc76a6bbbac6267781dc9e59496d2ce_hd.jpg" class="lazyload" data-srcset="../../%25E7%25AC%2594%25E8%25AE%25B0/%25E8%25AE%25B0%25E4%25BA%258B%25E6%259C%25AC/static/Linux.access/6bc76a6bbbac6267781dc9e59496d2ce_hd.jpg" srcset="data:image/png;base64,666" alt="img"></p><p><strong>配置</strong></p><p>zsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc，在最下面会发现这么一行字：</p><p># Customize to your needs…</p><p>可以在此处定义自己的环境变量和别名，当然，oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。</p><p>接下来进行别名的设置，我自己的部分配置如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">alias cls&#x3D;&#39;clear&#39;alias ll&#x3D;&#39;ls -l&#39;alias la&#x3D;&#39;ls -a&#39;alias vi&#x3D;&#39;vim&#39;alias javac&#x3D;&quot;javac -J-Dfile.encoding&#x3D;utf8&quot;alias grep&#x3D;&quot;grep --color&#x3D;auto&quot;alias -s html&#x3D;mate   # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开alias -s rb&#x3D;mate     # 在命令行直接输入 ruby 文件，会在 TextMate 中打开alias -s py&#x3D;vi       # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js&#x3D;vialias -s c&#x3D;vialias -s java&#x3D;vialias -s txt&#x3D;vialias -s gz&#x3D;&#39;tar -xzvf&#39;alias -s tgz&#x3D;&#39;tar -xzvf&#39;alias -s zip&#x3D;&#39;unzip&#39;alias -s bz2&#x3D;&#39;tar -xjvf&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>zsh 的牛粪之处在于不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如：</p><p>alias -s html=mate，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取 hello.html； alias -s gz=’tar -xzvf’，表示自动解压后缀为 gz 的压缩包。</p><p>总之，只有想不到，木有做不到。</p><p>设置完环境变量和别名之后，基本上就可以用了，如果你是个主题控，还可以玩玩 zsh 的主题。在 .zshrc 里找到ZSH_THEME，就可以设置主题了，默认主题是：</p><p>ZSH_THEME=”robbyrussell”</p><p>oh my zsh 提供了数十种主题，相关文件在~/.oh-my-zsh/themes目录下，你可以随意选择，也可以编辑主题满足自己的变态需求，我采用了默认主题robbyrussell，不过做了一点小小的改动：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">PROMPT&#x3D;&#39;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125;% %&#123;$reset_color%&#125;&gt;&#39;#PROMPT&#x3D;&#39;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p %&#123;$fg[cyan]%&#125;%c %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125; % %&#123;$reset_color%&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对照原来的版本，我把 c 改为 d，c 表示当前目录，d 表示绝对路径，另外在末尾增加了一个「 &gt; 」，改完之后的效果是这样的：</p><p>大家可以尝试进行改造，也算个趣事。</p><p>最后我们来说说插件。</p><p><strong>插件</strong></p><p>oh my zsh 项目提供了完善的插件体系，相关的文件在~/.oh-my-zsh/plugins目录下，默认提供了100多种，大家可以根据自己的实际学习和工作环境采用，想了解每个插件的功能，只要打开相关目录下的 zsh 文件看一下就知道了。插件也是在.zshrc里配置，找到plugins关键字，你就可以加载自己的插件了，系统默认加载 git ，你可以在后面追加内容，如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">plugins&#x3D;(git textmate ruby autojump osx mvn gradle)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面简单介绍几个：</p><p>1、git：当你处于一个 git 受控的目录下时，Shell 会明确显示 「git」和 branch，如上图所示，另外对 git 很多命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh</p><p>2、textmate：mr可以创建 ruby 的框架项目，tm finename 可以用 textmate 打开指定文件。</p><p>3、osx：tab 增强，quick-look filename 可以直接预览文件，man-preview grep 可以生成 grep手册 的pdf 版本等。</p><p>4、autojump：zsh 和 autojump 的组合形成了 zsh 下最强悍的插件，今天我们主要说说这货。</p><p>首先安装autojump，如果你用 Mac，可以使用 brew 安装：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">brew install autojump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果是 Linux，去下载 autojump 的最新版本，比如：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">wget https:&#x2F;&#x2F;github.com&#x2F;downloads&#x2F;joelthelion&#x2F;autojump&#x2F;autojump_v21.1.2.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压缩后进入目录，执行</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">.&#x2F;install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>最后把以下代码加入.zshrc：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">[[ -s ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh ]] &amp;&amp; . ~&#x2F;.autojump&#x2F;etc&#x2F;profile.d&#x2F;autojump.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>至此，安装、配置、插件三位一体，终极 Shell 全面登场。退出终端会话重新登录，开始感受 zsh 的训疾如风！</p><p><strong>使用 zsh</strong></p><p>1、兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。</p><p>2、强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。</p><p>3、智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的……</p><p>4、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n/p/f/b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全</p><p>5、智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。</p><p>6、目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。</p><p>7、在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。</p><p>8、通配符搜索：ls -l *<em>/</em>.sh，可以递归显示当前目录下的 shell 文件，文件少时可以代替 find，文件太多就歇菜了。</p><p>9、更强的别名：请参考配置一节。</p><p>10、插件支持：请参考插件一节。</p><p>……</p><p>看完这篇文章，你就知道，zsh一出，无人再与争锋！终极二字不是盖的。</p><p>如果你是个正在使用 shell程序员，如果你依然准备使用 bash，那就去面壁和忏悔吧，别说你订阅过 MacTalk！</p><p>感谢那位开发了 oh my zsh 的无聊程序员，他可能没有因此收获物质上的利益，但是他的代码提升了无数程序员的效率，节省了大量的时间，我们说，程序员改变世界！</p><p>MacTalk 写的多了，朋友和家人都不太理解，这玩意赚不了钱争不了名，写来何用？我想，能够学习、编码、写作，并做出一点帮助别人的东西，总好过炒股炒房的价值吧……</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux入门2 常用基本命令</title>
      <link href="2020/12/02/Linux/Linux%E5%85%A5%E9%97%A82%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>2020/12/02/Linux/Linux%E5%85%A5%E9%97%A82%20%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>对于linux系统来说，你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p></blockquote><h2 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h2><p>Linux系统目录结构为树状结构，最顶级的目录为根目录 /，一切资源都挂载在根目录下。<br>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>先了解一下绝对路径和相对路径</p><blockquote><p><strong>绝对路径和相对路径</strong> </p><p><strong>绝对路径：</strong><br>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><p><strong>相对路径：</strong><br>路径的写法，不是由 / 写起，而是由当前目录写起    ‘..’ 表示上一级目录</p><p>例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man</p></blockquote><h3 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls# 列出目录cd# 切换目录pwd# 显示目前的目录mkdir# 创建一个新的目录rmdir# 删除一个空的目录cp# 复制文件或目录rm# 移除文件或目录mv# 移动文件与目录，或修改文件与目录的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><h3 id="ls（列出目录）"><a href="#ls（列出目录）" class="headerlink" title="ls（列出目录）"></a>ls（列出目录）</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls [-aAdfFhilnrRSt] 目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>例子</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 将目录下的所有文件列出来(含属性与隐藏档)ls -al ~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="cd-（切换目录）"><a href="#cd-（切换目录）" class="headerlink" title="cd （切换目录）"></a>cd （切换目录）</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd [相对路径或绝对路径]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例子：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 在&#39;&#x2F;&#39;目录下,切换到用户目录下[root@localhost &#x2F;]# cd home[root@localhost home]# # 回到上一级[root@localhost home]# cd ..[root@localhost &#x2F;]# # 回到根目录[root@localhost &#x2F;]# cd &#x2F;[root@localhost &#x2F;]# # 表示回到自己的家目录，亦即是 &#x2F;root 这个目录[root@localhost &#x2F;]# cd ~[root@localhost ~]# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>多操作几次应该就可以很好的理解 cd 命令的。</p><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd ( 显示目前所在的目录 )"></a>pwd ( 显示目前所在的目录 )</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><pre class="line-numbers language-none"><code class="language-none">pwd [-P]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：**-P**（注意是大写） ：显示出确实的路径，而非使用连接(link) 路径。</p><p>例子：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 单纯显示出目前的工作目录[root@localhost ~]# pwd&#x2F;root# 如果是链接，要显示真实地址，可以使用 -P参数[root@localhost bin]# pwd&#x2F;bin[root@localhost bin]# pwd -P&#x2F;usr&#x2F;bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mkdir-（创建新目录）"><a href="#mkdir-（创建新目录）" class="headerlink" title="mkdir （创建新目录）"></a>mkdir （创建新目录）</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mkdir [-mp] 目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>测试：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看当前目录下的目录与文件[root@localhost ~]# lsanaconda-ks.cfg  prel  UnixBench  UnixBench5.1.3.tgz# 创建一个 test 文件夹[root@localhost ~]# mkdir test[root@localhost ~]# lsanaconda-ks.cfg  prel  test  UnixBench  UnixBench5.1.3.tgz# 创建多层级目录[root@localhost ~]# mkdir test&#x2F;test1&#x2F;test2&#x2F;test3mkdir: cannot create directory ‘test&#x2F;test1&#x2F;test2&#x2F;test3’: No such file or directory  # &lt;&#x3D;&#x3D; 没办法直接创建此目录啊！# 加了这个 -p 的选项，可以自行帮你创建多层目录！[root@localhost ~]# mkdir -p test&#x2F;test1&#x2F;test2&#x2F;test3# 创建权限为 rwx--x--x 的目录。[root@localhost ~]# mkdir -m 711 test1[root@localhost ~]# ls -ltotal 260-rw-------. 1 root root   1260 Dec  1 08:43 anaconda-ks.cfg-rw-r--r--. 1 root root 116267 Dec  3 00:22 preldrwxr-xr-x. 3 root root     19 Dec  3 04:07 testdrwx--x--x. 2 root root      6 Dec  3 04:08 test1drwxr-xr-x. 7 root root    178 Dec  3 00:18 UnixBench-rw-r--r--. 1 root root 143259 Jun 30  2017 UnixBench5.1.3.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir ( 删除空的目录 )"></a>rmdir ( 删除空的目录 )</h3><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rmdir [-p] 目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：**-p ：**连同上一级『空的』目录也一起删除</p><p>例子：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 看看有多少目录存在？[root@kuangshen home]# ls -ldrwxr-xr-x 2 root root  4096 Mar 12 21:55 testdrwxr-xr-x 3 root root  4096 Mar 12 21:56 test1drwx--x--x 2 root root  4096 Mar 12 21:58 test2# 可直接删除掉，没问题[root@localhost ~]# rmdir test1# 因为尚有内容，所以无法删除！[root@localhost ~]# rmdir testrmdir: failed to remove ‘test’: Directory not empty# 利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 依次删除。[root@localhost ~]# rmdir -p test&#x2F;test1&#x2F;test2&#x2F;test3[root@localhost ~]# lsanaconda-ks.cfg  prel  UnixBench  UnixBench5.1.3.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：这个 rmdir 仅能删除空的目录，可以使用 rm 命令来删除非空目录</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp ( 复制文件或目录 )"></a>cp ( 复制文件或目录 )</h3><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cp [-adfilprsu] 来源(source) 目标(destination)cp [options] source1 source2 source3 .... directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式连结(hard link)的连结档创建，而非复制文件本身。</li><li><strong>-s：</strong>复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>例子：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 找一个有文件的目录, 我用的是&#x2F;root[root@localhost ~]# ls &#x2F;rootanaconda-ks.cfg  prel  UnixBench  UnixBench5.1.3.tgz# 复制 root目录下的prel 到 home目录下[root@localhost ~]# cp &#x2F;root&#x2F;prel &#x2F;home[root@localhost ~]# ls &#x2F;homeprel# 再次复制，加上-i参数，增加覆盖询问[root@localhost ~]# cp -i &#x2F;root&#x2F;prel &#x2F;homecp: overwrite ‘&#x2F;home&#x2F;prel’? y  # n(no)不覆盖，y(yes)为覆盖<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm ( 移除文件或目录 )"></a>rm ( 移除文件或目录 )</h3><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">rm [-fir] 文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul><p>测试：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 将刚刚在 cp 的实例中创建的 prel 删除掉！[root@localhost ~]# rm -i &#x2F;home&#x2F;prelrm: remove regular file ‘&#x2F;home&#x2F;prel’? y# 如果加上 -i 的选项就会主动询问喔，避免误删之类的错误！# 尽量不要在服务器上使用 rm -rf &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv  ( 移动文件与目录，或修改名称 )"></a>mv  ( 移动文件与目录，或修改名称 )</h3><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">mv [-fiu] source destinationmv [options] source1 source2 source3 .... directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>测试：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 复制一个文件到当前目录[root@localhost ~]# cp -i &#x2F;root&#x2F;prel &#x2F;home# 创建一个文件夹 test[root@localhost ~]# cd &#x2F;home[root@localhost home]# mkdir test[root@localhost home]# # 将复制过来的文件移动到我们创建的目录，并查看[root@localhost home]# mv prel test[root@localhost home]# lstest[root@localhost home]# cd test[root@localhost test]# lsprel# 将文件夹重命名，然后再次查看！[root@localhost test]# cd ..[root@localhost home]# mv test mvtest[root@localhost home]# lsmvtest[root@localhost home]# cd mvtest&#x2F;[root@localhost mvtest]# lsprel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h1><blockquote><p>看懂文件属性</p></blockquote><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组，如：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JGpeIS4j9q3B4LQhsQkFiauXAQN0qOnVCYvj7Cm1oQbvexVDFqPhUIeTe83BdAHlXCJhGoNabSFKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JGpeIS4j9q3B4LQhsQkFiauXAQN0qOnVCYvj7Cm1oQbvexVDFqPhUIeTe83BdAHlXCJhGoNabSFKQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>实例中，boot文件的第一个属性用”d”表示。”d”在Linux中代表该文件是一个目录文件。</p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等：</p><ul><li>当为[ <strong>d</strong> ]则是目录</li><li>当为[ <strong>-</strong> ]则是文件；</li><li>若是[ <strong>l</strong> ]则表示为链接文档 ( link file )；</li><li>若是[ <strong>b</strong> ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )；</li><li>若是[ <strong>c</strong> ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。</li></ul><p>接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。</p><p>其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。</p><p>要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。</p><p>每个文件的属性由左边第一部分的10个字符来确定（如上图）</p><p>从左至右用0-9这些数字来表示。</p><p>第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。</p><p>其中：</p><p>第1、4、7位表示读权限，如果用”r”字符表示，则有读权限，如果用”-“字符表示，则没有读权限；</p><p>第2、5、8位表示写权限，如果用”w”字符表示，则有写权限，如果用”-“字符表示没有写权限；</p><p>第3、6、9位表示可执行权限，如果用”x”字符表示，则有执行权限，如果用”-“字符表示，则没有执行权限。</p><p>对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。</p><p>同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。</p><p>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。</p><p>因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</p><p>root用户拥有对所有文件的所有权限</p><p>在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。</p><h2 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h2><p><strong>1、chgrp：更改文件属组</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chgrp [-R] 属组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p><strong>2、chown：更改文件属主，也可以同时更改文件属组</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chown [–R] 属主名 文件名chown [-R] 属主名：属组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>3、chmod：更改文件9个属性</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chmod [-R] xyz 文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Linux文件属性有两种设置方法，一种是数字，一种是符号。</p><p>Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。</p><p>先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">r:4w:2x:1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">chmod 770 filename<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以自己下去多进行测试！</p><h1 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h1><blockquote><p>概述</p></blockquote><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><h2 id="cat-从第一行开始显示文件内容"><a href="#cat-从第一行开始显示文件内容" class="headerlink" title="cat 从第一行开始显示文件内容"></a>cat 从第一行开始显示文件内容</h2><p>语法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cat [-AbEnTv]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>测试：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看网络配置: 文件地址 &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;[root@kuangshen ~]# cat &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0DEVICE&#x3D;eth0BOOTPROTO&#x3D;dhcpONBOOT&#x3D;yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="tac-从末尾开始显示文件内容"><a href="#tac-从末尾开始显示文件内容" class="headerlink" title="tac 从末尾开始显示文件内容"></a>tac 从末尾开始显示文件内容</h2><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[root@kuangshen ~]# tac &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0ONBOOT&#x3D;yesBOOTPROTO&#x3D;dhcpDEVICE&#x3D;eth0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>nl  显示行号</p></blockquote><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">nl [-bnw] 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>测试：</p><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen ~]# nl &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth01DEVICE&#x3D;eth02BOOTPROTO&#x3D;dhcp3ONBOOT&#x3D;yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>more  一页一页翻动</p></blockquote><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter   ：代表向下翻『一行』；</li><li>/字串   ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f    ：立刻显示出档名以及目前显示的行数；</li><li>q    ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen etc]# more &#x2F;etc&#x2F;csh.login....(中间省略)....--More--(28%) # 重点在这一行喔！你的光标也会在这里等待你的命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>less  一页一页翻动，以下实例输出/etc/man.config文件的内容：</p></blockquote><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串  ：向下搜寻『字串』的功能；</li><li>?字串  ：向上搜寻『字串』的功能；</li><li>n   ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N   ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q   ：离开 less 这个程序；</li></ul><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen etc]# more &#x2F;etc&#x2F;csh.login....(中间省略)....:   # 这里可以等待你输入命令！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>head  取出文件前面几行</p></blockquote><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">head [-n number] 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：**-n** 后面接数字，代表显示几行的意思！</p><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen etc]# head -n 20 &#x2F;etc&#x2F;csh.login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>tail  取出文件后面几行</p></blockquote><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">tail [-n number] 文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><p>默认的情况中，显示最后 10 行！若要显示最后 20 行，就得要这样：</p><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen etc]# tail -n 20 &#x2F;etc&#x2F;csh.login<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>拓展：Linux 链接概念</p></blockquote><p>Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。</p><p>情况下，<strong>ln</strong> 命令产生硬链接。</p><p><strong>硬连接</strong></p><p>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><strong>软连接</strong></p><p>另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><p><strong>测试：</strong></p><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen &#x2F;]# cd &#x2F;home[root@kuangshen home]# touch f1 # 创建一个测试文件f1[root@kuangshen home]# lsf1[root@kuangshen home]# ln f1 f2     # 创建f1的一个硬连接文件f2[root@kuangshen home]# ln -s f1 f3   # 创建f1的一个符号连接文件f3[root@kuangshen home]# ls -li       # -i参数显示文件的inode节点信息397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f1397247 -rw-r--r-- 2 root root     0 Mar 13 00:50 f2397248 lrwxrwxrwx 1 root root     2 Mar 13 00:50 f3 -&gt; f1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的结果中可以看出，硬连接文件 f2 与原文件 f1 的 inode 节点相同，均为 397247，然而符号连接文件的 inode 节点不同。</p><pre class="line-numbers language-none"><code class="language-none"># echo 字符串输出 &gt;&gt; f1 输出到 f1文件[root@kuangshen home]# echo &quot;I am f1 file&quot; &gt;&gt;f1[root@kuangshen home]# cat f1I am f1 file[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3I am f1 file[root@kuangshen home]# rm -f f1[root@kuangshen home]# cat f2I am f1 file[root@kuangshen home]# cat f3cat: f3: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上面的测试可以看出：当删除原始文件 f1 后，硬连接 f2 不受影响，但是符号连接 f1 文件无效；</p><p>依此您可以做一些相关的测试，可以得到以下全部结论：</p><ul><li>删除符号连接f3,对f1,f2无影响；</li><li>删除硬连接f2，对f1,f3也无影响；</li><li>删除原文件f1，对硬连接f2没有影响，导致符号连接f3失效；</li><li>同时删除原文件f1,硬连接f2，整个文件会真正的被删除。</li></ul><p>Vim编辑器</p><blockquote><p>什么是Vim编辑器</p></blockquote><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。</p><p>vim 则可以说是程序开发者的一项很好用的工具。</p><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。</p><p>连 vim 的官方网站 (<a href="http://www.vim.org/">http://www.vim.org</a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。</p><p>vim 键盘图：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4RsQuEaoMI78gr3jGxkVH7ONWyDHmremOHiaUibc3sqPRfEuVuHqicfqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4RsQuEaoMI78gr3jGxkVH7ONWyDHmremOHiaUibc3sqPRfEuVuHqicfqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><blockquote><p>三种使用模式</p></blockquote><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）</strong>和<strong>底线命令模式（Last line mode）</strong>。这三种模式的作用分别是：</p><p><strong>命令模式：</strong></p><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><p><strong>输入模式：</strong></p><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><p><strong>底线命令模式</strong></p><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMIxVoDyQ4LWxSbHDjAYfHuId7xfHHichtqZK2ehsXvcC9KiaibPf68s9dg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMIxVoDyQ4LWxSbHDjAYfHuId7xfHHichtqZK2ehsXvcC9KiaibPf68s9dg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><blockquote><p>上手体验一下，在home目录下测试</p></blockquote><p>如果你想要使用 vi 来建立一个名为 kuangstudy.txt 的文件时，你可以这样做：</p><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen home]# vim kuangstudy.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后就会进入文件</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4461hqusRbQZ32967zqUhChqXbCzJTN3I20RpiaVbFqWvHicvicc9icBUQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggM4461hqusRbQZ32967zqUhChqXbCzJTN3I20RpiaVbFqWvHicvicc9icBUQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMEarICtkr8ia1N6zqcuv3ROj1TBDoMicM5DoYzaGU29qQ2mbQhlBUbbww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMEarICtkr8ia1N6zqcuv3ROj1TBDoMicM5DoYzaGU29qQ2mbQhlBUbbww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><strong>按下 ESC 按钮回到一般模式</strong></p><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><p>在一般模式中按下 <strong>:wq</strong> 储存后离开 vim！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMeA5EoVUt4j2544oibjdoeRah06s2ALh1QDXwep41Mj4ZnhWyb6icdp0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7L1I72C1HrwJ9bG6XAbVggMeA5EoVUt4j2544oibjdoeRah06s2ALh1QDXwep41Mj4ZnhWyb6icdp0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>OK! 这样我们就成功创建了一个 kuangstudy.txt 的文件。</p><blockquote><p>Vim 按键说明</p></blockquote><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><p><strong>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p><table><thead><tr><th align="left">移动光标的方法</th><th></th></tr></thead><tbody><tr><td align="left">h 或 向左箭头键(←)</td><td>光标向左移动一个字符</td></tr><tr><td align="left">j 或 向下箭头键(↓)</td><td>光标向下移动一个字符</td></tr><tr><td align="left">k 或 向上箭头键(↑)</td><td>光标向上移动一个字符</td></tr><tr><td align="left">l 或 向右箭头键(→)</td><td>光标向右移动一个字符</td></tr><tr><td align="left">[Ctrl] + [f]</td><td>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [b]</td><td>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td align="left">[Ctrl] + [d]</td><td>屏幕『向下』移动半页</td></tr><tr><td align="left">[Ctrl] + [u]</td><td>屏幕『向上』移动半页</td></tr><tr><td align="left">+</td><td>光标移动到非空格符的下一行</td></tr><tr><td align="left">-</td><td>光标移动到非空格符的上一行</td></tr><tr><td align="left">n&lt; space&gt;</td><td>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。</td></tr><tr><td align="left">0 或功能键[Home]</td><td>这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td align="left">$ 或功能键[End]</td><td>移动到这一行的最后面字符处(常用)</td></tr><tr><td align="left">H</td><td>光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td align="left">M</td><td>光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td align="left">L</td><td>光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td align="left">G</td><td>移动到这个档案的最后一行(常用)</td></tr><tr><td align="left">nG</td><td>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td align="left">gg</td><td>移动到这个档案的第一行，相当于 1G 啊！(常用)</td></tr><tr><td align="left">n&lt; Enter&gt;</td><td>n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><table><thead><tr><th align="left">搜索替换</th><th></th></tr></thead><tbody><tr><td align="left">/word</td><td>向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用)</td></tr><tr><td align="left">?word</td><td>向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr></tbody></table><table><thead><tr><th align="left">删除、复制与粘贴</th><th></th></tr></thead><tbody><tr><td align="left">x, X</td><td>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td align="left">nx</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>删除游标所在的那一整行(常用)</td></tr><tr><td align="left">ndd</td><td>n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td align="left">d1G</td><td>删除光标所在到第一行的所有数据</td></tr><tr><td align="left">dG</td><td>删除光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td>删除游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y1G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。(常用)</td></tr><tr><td align="left">J</td><td>将光标所在行与下一行的数据结合成同一行</td></tr><tr><td align="left">c</td><td>重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr><tr><td align="left">[Ctrl]+r</td><td>重做上一个动作。(常用)</td></tr></tbody></table><p><strong>第二部分：一般模式切换到编辑模式的可用的按钮说明</strong></p><table><thead><tr><th align="left">进入输入或取代的编辑模式</th><th></th></tr></thead><tbody><tr><td align="left">i, I</td><td>进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。(常用)</td></tr><tr><td align="left">a, A</td><td>进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td align="left">o, O</td><td>进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td align="left">r, R</td><td>进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td align="left">[Esc]</td><td>退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p><strong>第三部分：一般模式切换到指令行模式的可用的按钮说明</strong></p><table><thead><tr><th align="left">指令行的储存、离开等指令</th><th></th></tr></thead><tbody><tr><td align="left">:w</td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td align="left">:w!</td><td>若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td align="left">:q</td><td>离开 vi (常用)</td></tr><tr><td align="left">:q!</td><td>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td align="left">注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td></td></tr><tr><td align="left">:wq</td><td>储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td align="left">ZZ</td><td>这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td align="left">:w [filename]</td><td>将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td align="left">:r [filename]</td><td>在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td align="left">:n1,n2 w [filename]</td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td align="left">:! command</td><td>暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td align="left">:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td align="left">:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><blockquote><p>简介</p></blockquote><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>每个用户账号都拥有一个唯一的用户名和各自的口令。</p><p>用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>实现用户账号的管理，要完成的工作主要有如下几个方面：</p><ul><li>用户账号的添加、删除与修改。</li><li>用户口令的管理。</li><li>用户组的管理。</li></ul><blockquote><p>用户账号的管理</p></blockquote><p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。</p><p>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。</p><blockquote><p>添加账号 useradd</p></blockquote><pre class="line-numbers language-none"><code class="language-none">useradd 选项 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数说明：</p><ul><li><p>选项 :</p></li><li><ul><li>-c comment 指定一段注释性描述。<ul><li>-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</li><li>-g 用户组 指定用户所属的用户组。</li><li>-G 用户组，用户组 指定用户所属的附加组。</li><li>-m　使用者目录如不存在则自动建立。</li><li>-s Shell文件 指定用户的登录Shell。</li><li>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</li></ul></li></ul></li><li><p>用户名 :</p></li><li><ul><li>指定新账号的登录名。</li></ul></li></ul><p>测试：</p><pre class="line-numbers language-none"><code class="language-none"># 此命令创建了一个用户kuangshen，其中-m选项用来为登录名kuangshen产生一个主目录 &#x2F;home&#x2F;kuangshen[root@kuangshen home]# useradd -m kuangshen<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。</p><blockquote><p>Linux下如何切换用户</p></blockquote><p>1.切换用户的命令为：su username 【username是你的用户名哦】</p><p>2.从普通用户切换到root用户，还可以使用命令：sudo su</p><p>3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令</p><p>4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】</p><p>$表示普通用户</p><p>#表示超级用户，也就是root用户</p><blockquote><p>删除帐号</p></blockquote><p>如果一个用户的账号不再使用，可以从系统中删除。</p><p>删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p><p>删除一个已有的用户账号使用userdel命令，其格式如下：</p><pre class="line-numbers language-none"><code class="language-none">userdel 选项 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用的选项是 <strong>-r</strong>，它的作用是把用户的主目录一起删除。</p><pre class="line-numbers language-none"><code class="language-none">[root@kuangshen home]# userdel -r kuangshen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令删除用户kuangshen在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p><blockquote><p>修改帐号</p></blockquote><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p><p>修改已有用户的信息使用usermod命令，其格式如下：</p><pre class="line-numbers language-none"><code class="language-none">usermod 选项 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none"># usermod -s &#x2F;bin&#x2F;ksh -d &#x2F;home&#x2F;z –g developer kuangshen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令将用户kuangshen的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p><blockquote><p>用户口令的管理</p></blockquote><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p><p>命令的格式为：</p><pre class="line-numbers language-none"><code class="language-none">passwd 选项 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可使用的选项：</p><ul><li>-l 锁定口令，即禁用账号。</li><li>-u 口令解锁。</li><li>-d 使账号无口令。</li><li>-f 强迫用户下次登录时修改口令。</li></ul><p>如果默认用户名，则修改当前用户的口令。</p><p>例如，假设当前用户是kuangshen，则下面的命令修改该用户自己的口令：</p><pre class="line-numbers language-none"><code class="language-none">$ passwd Old password:******New password:*******Re-enter new password:*******<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p><pre class="line-numbers language-none"><code class="language-none"># passwd kuangshenNew password:*******Re-enter new password:*******<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。</p><p>为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。</p><p>为用户指定空口令时，执行下列形式的命令：</p><pre class="line-numbers language-none"><code class="language-none"># passwd -d kuangshen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令将用户 kuangshen的口令删除，这样用户 kuangshen下一次登录时，系统就不再允许该用户登录了。</p><p>passwd 命令还可以用 -l(lock) 选项锁定某一用户，使其不能登录，例如：</p><pre class="line-numbers language-none"><code class="language-none"># passwd -l kuangshen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><blockquote><p>增加一个新的用户组使用groupadd命令</p></blockquote><pre class="line-numbers language-none"><code class="language-none">groupadd 选项 用户组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以使用的选项有：</p><ul><li>-g GID 指定新用户组的组标识号（GID）。</li><li>-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</li></ul><p>实例1：</p><pre class="line-numbers language-none"><code class="language-none"># groupadd group1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</p><p>实例2：</p><pre class="line-numbers language-none"><code class="language-none"># groupadd -g 101 group2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。</p><blockquote><p>如果要删除一个已有的用户组，使用groupdel命令</p></blockquote><pre class="line-numbers language-none"><code class="language-none">groupdel 用户组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>例如：</p><pre class="line-numbers language-none"><code class="language-none"># groupdel group1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令从系统中删除组group1。</p><blockquote><p>修改用户组的属性使用groupmod命令</p></blockquote><pre class="line-numbers language-none"><code class="language-none">groupmod 选项 用户组<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>常用的选项有：</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</li><li>-n新用户组 将用户组的名字改为新名字</li></ul><pre class="line-numbers language-none"><code class="language-none"># 此命令将组group2的组标识号修改为102。groupmod -g 102 group2# 将组group2的标识号改为10000，组名修改为group3。groupmod –g 10000 -n group3 group2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>切换组</p></blockquote><p>如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p><p>用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：</p><pre class="line-numbers language-none"><code class="language-none">$ newgrp root<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。</p><blockquote><p>/etc/passwd</p></blockquote><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。</p><p>下面分别介绍这些文件的内容。</p><p><strong>/etc/passwd文件是用户管理工作涉及的最重要的一个文件。</strong></p><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p><p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p><pre class="line-numbers language-none"><code class="language-none">＃ cat &#x2F;etc&#x2F;passwdroot:x:0:0:Superuser:&#x2F;:daemon:x:1:1:System daemons:&#x2F;etc:bin:x:2:2:Owner of system commands:&#x2F;bin:sys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys:adm:x:4:4:System accounting:&#x2F;usr&#x2F;adm:uucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp:auth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth:cron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron:listen:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls:lp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p><pre class="line-numbers language-none"><code class="language-none">用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1）”用户名”是代表用户账号的字符串。</p><p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。</p><p>为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。</p><p>2）“口令”一些系统中，存放着加密后的用户口令字。</p><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。</p><p>3）“用户标识号”是一个整数，系统内部用它来标识用户。</p><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><p>4）“组标识号”字段记录的是用户所属的用户组。</p><p>它对应着/etc/group文件中的一条记录。</p><p>5)“注释性描述”字段记录着用户的一些个人情况。</p><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用作finger命令的输出。</p><p>6)“主目录”，也就是用户的起始工作目录。</p><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p><p>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</p><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。</p><p>用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><p>8)系统中有一类用户称为伪用户（pseudo users）。</p><p>这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。</p><p>常见的伪用户如下所示：</p><pre class="line-numbers language-none"><code class="language-none">伪 用 户 含 义bin 拥有可执行的用户命令文件sys 拥有系统文件adm 拥有帐户文件uucp UUCP使用lp lp或lpd子系统使用nobody NFS使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>/etc/shadow</p></blockquote><p><strong>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</strong></p><p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p><p><strong>2、/etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生</strong></p><p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p><pre class="line-numbers language-none"><code class="language-none">登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>“登录名”是与/etc/passwd文件中的登录名相一致的用户账号</li><li>“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。</li><li>“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。</li><li>“最小时间间隔”指的是两次修改口令之间所需的最小天数。</li><li>“最大时间间隔”指的是口令保持有效的最大天数。</li><li>“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。</li><li>“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。</li><li>“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</li></ol><blockquote><p>/etc/group</p></blockquote><p>用户组的所有信息都存放在/etc/group文件中。</p><p>将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。</p><p>用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。</p><p>用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有：</p><pre class="line-numbers language-none"><code class="language-none">组名:口令:组标识号:组内用户列表<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li><p>“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</p></li><li><p>“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。</p></li><li><p>“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。</p></li><li><p>“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p></li></ol><h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><blockquote><p>概述</p></blockquote><p>Linux磁盘管理好坏直接关系到整个系统的性能问题。</p><p>Linux磁盘管理常用命令为 df、du。</p><ul><li>df ：列出文件系统的整体磁盘使用量</li><li>du：检查磁盘空间使用量</li></ul><h3 id="df（检查磁盘占用情况）"><a href="#df（检查磁盘占用情况）" class="headerlink" title="df（检查磁盘占用情况）"></a>df（检查磁盘占用情况）</h3><p>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">df [-ahikHTm] [目录或文件名]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li><li>-k ：以 KBytes 的容量显示各文件系统；</li><li>-m ：以 MBytes 的容量显示各文件系统；</li><li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li><li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li><li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li><li>-i ：不用硬盘容量，而以 inode 的数量来显示</li></ul><p>测试：</p><pre class="line-numbers language-none"><code class="language-none"># 将系统内所有的文件系统列出来！# 在 Linux 底下如果 df 没有加任何选项# 那么默认会将系统内所有的 (不含特殊内存内的文件系统与 swap) 都以 1 Kbytes 的容量来列出来！[root@kuangshen &#x2F;]# dfFilesystem     1K-blocks   Used Available Use% Mounted ondevtmpfs          889100       0    889100   0% &#x2F;devtmpfs             899460     704    898756   1% &#x2F;dev&#x2F;shmtmpfs             899460     496    898964   1% &#x2F;runtmpfs             899460       0    899460   0% &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;dev&#x2F;vda1       41152812 6586736  32662368  17% &#x2F;tmpfs             179896       0    179896   0% &#x2F;run&#x2F;user&#x2F;0# 将容量结果以易读的容量格式显示出来[root@kuangshen &#x2F;]# df -hFilesystem     Size Used Avail Use% Mounted ondevtmpfs       869M     0 869M   0% &#x2F;devtmpfs           879M 708K 878M   1% &#x2F;dev&#x2F;shmtmpfs           879M 496K 878M   1% &#x2F;runtmpfs           879M     0 879M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;dev&#x2F;vda1       40G  6.3G   32G  17% &#x2F;tmpfs           176M     0 176M   0% &#x2F;run&#x2F;user&#x2F;0# 将系统内的所有特殊文件格式及名称都列出来[root@kuangshen &#x2F;]# df -aTFilesystem     Type       1K-blocks   Used Available Use% Mounted onsysfs         sysfs               0       0         0    - &#x2F;sysproc           proc                0       0         0    - &#x2F;procdevtmpfs       devtmpfs       889100       0    889100   0% &#x2F;devsecurityfs     securityfs          0       0         0    - &#x2F;sys&#x2F;kernel&#x2F;securitytmpfs         tmpfs          899460     708    898752   1% &#x2F;dev&#x2F;shmdevpts         devpts              0       0         0    - &#x2F;dev&#x2F;ptstmpfs         tmpfs          899460     496    898964   1% &#x2F;runtmpfs         tmpfs          899460       0    899460   0% &#x2F;sys&#x2F;fs&#x2F;cgroupcgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemdpstore         pstore              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;pstorecgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezercgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpusetcgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlbcgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkiocgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_priocgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memorycgroup         cgroup              0       0         0    - &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pidscgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacctcgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devicescgroup         cgroup              0       0         0    -&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_eventconfigfs       configfs            0       0         0    - &#x2F;sys&#x2F;kernel&#x2F;config&#x2F;dev&#x2F;vda1     ext4         41152812 6586748  32662356  17% &#x2F;systemd-1      -                   -       -         -    -&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_miscmqueue         mqueue              0       0         0    - &#x2F;dev&#x2F;mqueuedebugfs       debugfs             0       0         0    - &#x2F;sys&#x2F;kernel&#x2F;debughugetlbfs     hugetlbfs           0       0         0    - &#x2F;dev&#x2F;hugepagestmpfs         tmpfs          179896       0    179896   0% &#x2F;run&#x2F;user&#x2F;0binfmt_misc   binfmt_misc         0       0         0    -&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;binfmt_misc# 将 &#x2F;etc 底下的可用的磁盘容量以易读的容量格式显示[root@kuangshen &#x2F;]# df -h &#x2F;etcFilesystem     Size Used Avail Use% Mounted on&#x2F;dev&#x2F;vda1       40G  6.3G   32G  17% &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>du</p></blockquote><p>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。</p><p>语法：</p><pre class="line-numbers language-none"><code class="language-none">du [-ahskm] 文件或目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</li><li>-h ：以人们较易读的容量格式 (G/M) 显示；</li><li>-s ：列出总量而已，而不列出每个各别的目录占用容量；</li><li>-S ：不包括子目录下的总计，与 -s 有点差别。</li><li>-k ：以 KBytes 列出容量显示；</li><li>-m ：以 MBytes 列出容量显示；</li></ul><p>测试：</p><pre class="line-numbers language-none"><code class="language-none"># 只列出当前目录下的所有文件夹容量（包括隐藏文件夹）:# 直接输入 du 没有加任何选项时，则 du 会分析当前所在目录的文件与目录所占用的硬盘空间。[root@kuangshen home]# du16.&#x2F;redis8.&#x2F;www&#x2F;.oracle_jre_usage  # 包括隐藏文件的目录24.&#x2F;www48.                        # 这个目录(.)所占用的总量# 将文件的容量也列出来[root@kuangshen home]# du -a4.&#x2F;redis&#x2F;.bash_profile4.&#x2F;redis&#x2F;.bash_logout    ....中间省略....4.&#x2F;kuangstudy.txt # 有文件的列表了48.# 检查根目录底下每个目录所占用的容量[root@kuangshen home]# du -sm &#x2F;*0&#x2F;bin146&#x2F;boot.....中间省略....0&#x2F;proc.....中间省略....1&#x2F;tmp3026&#x2F;usr  # 系统初期最大就是他了啦！513&#x2F;var2666&#x2F;www<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通配符 * 来代表每个目录。</p><p>与 df 不一样的是，du 这个命令其实会直接到文件系统内去搜寻所有的文件数据。</p><blockquote><p>磁盘挂载与卸除</p></blockquote><p>根文件系统之外的其他文件要想能够被访问，都必须通过“关联”至根文件系统上的某个目录来实现，此关联操作即为“挂载”，此目录即为“挂载点”,解除此关联关系的过程称之为“卸载”</p><p>Linux 的磁盘挂载使用mount命令，卸载使用umount命令。</p><p>磁盘挂载语法：</p><pre class="line-numbers language-none"><code class="language-none">mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-none"><code class="language-none"># 将 &#x2F;dev&#x2F;hdc6 挂载到 &#x2F;mnt&#x2F;hdc6 上面！[root@www ~]# mkdir &#x2F;mnt&#x2F;hdc6[root@www ~]# mount &#x2F;dev&#x2F;hdc6 &#x2F;mnt&#x2F;hdc6[root@www ~]# dfFilesystem           1K-blocks     Used Available Use% Mounted on&#x2F;dev&#x2F;hdc6              1976312     42072   1833836   3% &#x2F;mnt&#x2F;hdc6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>磁盘卸载命令 umount 语法：</p><pre class="line-numbers language-none"><code class="language-none">umount [-fn] 装置文件名或挂载点<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；</li><li>-n ：不升级 /etc/mtab 情况下卸除。</li></ul><p>卸载/dev/hdc6</p><pre class="line-numbers language-none"><code class="language-none">[root@www ~]# umount &#x2F;dev&#x2F;hdc6<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux更新源</title>
      <link href="2020/12/02/Linux/Linux%E6%9B%B4%E6%96%B0%E6%BA%90/"/>
      <url>2020/12/02/Linux/Linux%E6%9B%B4%E6%96%B0%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要换源"><a href="#为什么要换源" class="headerlink" title="为什么要换源"></a>为什么要换源</h2><blockquote><p>大多数官方源的服务器都在国外<br>so…</p></blockquote><h2 id="设置更新源镜像"><a href="#设置更新源镜像" class="headerlink" title="设置更新源镜像"></a>设置更新源镜像</h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p>配置文件位置：<code> /etc/apt</code></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 修改配置文件前建议先备份文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p>yum包管理器的配置文件位置 <code>/etc/yum.repos.d/CentOS-Base.repo</code></p><h4 id="通过安装脚本"><a href="#通过安装脚本" class="headerlink" title="通过安装脚本"></a>通过安装脚本</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cd &#x2F;etc&#x2F;yum.repos.d&#x2F;# 修改配置文件前建议先备份文件cp CentOS-Base.repo CentOS-Base.repo.bar# 下载163镜像源配置文件wget http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS7-Base-163.repo# 重新生成缓存yum clean allyum makecache<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="各大系统常见更新源"><a href="#各大系统常见更新源" class="headerlink" title="各大系统常见更新源"></a>各大系统常见更新源</h2><h3 id="Ubuntu-18-04"><a href="#Ubuntu-18-04" class="headerlink" title="Ubuntu 18.04"></a>Ubuntu 18.04</h3><h4 id="阿里源"><a href="#阿里源" class="headerlink" title="阿里源"></a>阿里源</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中科大源"><a href="#中科大源" class="headerlink" title="中科大源"></a>中科大源</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">deb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="163源"><a href="#163源" class="headerlink" title="163源"></a>163源</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="清华源"><a href="#清华源" class="headerlink" title="清华源"></a>清华源</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">deb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h3><p>并没有…123</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 镜像源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo子分类和父分类</title>
      <link href="2020/12/02/Hexo%E5%8D%9A%E5%AE%A2/Hexo%E5%AD%90%E5%88%86%E7%B1%BB%E5%92%8C%E7%88%B6%E5%88%86%E7%B1%BB/"/>
      <url>2020/12/02/Hexo%E5%8D%9A%E5%AE%A2/Hexo%E5%AD%90%E5%88%86%E7%B1%BB%E5%92%8C%E7%88%B6%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>随着博客量的增加，更细致的分类变得更有必要</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>格式</p>  <pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">categories:- Diary- Life<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  这种格式会使分类Life成为Diary的子分类，而不是并列分类</p></li><li><p>更复杂的格式</p>  <pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">categories:- [Diary, PlayStation]- [Diary, Games]- [Life]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux入门1 安装Linux</title>
      <link href="2020/12/02/Linux/Linux%E5%85%A5%E9%97%A81%20%E5%AE%89%E8%A3%85linux/"/>
      <url>2020/12/02/Linux/Linux%E5%85%A5%E9%97%A81%20%E5%AE%89%E8%A3%85linux/</url>
      
        <content type="html"><![CDATA[<h2 id="linux概述"><a href="#linux概述" class="headerlink" title="linux概述"></a>linux概述</h2><h3 id="什么是linux"><a href="#什么是linux" class="headerlink" title="什么是linux"></a>什么是linux</h3><p>看百科吧     <a href="https://zh.wikipedia.org/zh/Linux">维基百科</a>     <a href="https://baike.baidu.com/item/Linux">百度百科</a> </p><h3 id="linux入门概述"><a href="#linux入门概述" class="headerlink" title="linux入门概述"></a>linux入门概述</h3><blockquote><p>严格来说，linux只是一个操作系统内核<br>通常所说的 <strong>linux系统</strong> 是指以它为内核的一系列操作系统</p></blockquote><p><img src="https://s3.ax1x.com/2020/12/02/D5Gj8x.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/02/D5Gj8x.jpg" srcset="data:image/png;base64,666"></p><blockquote><p>Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包。<br>常见的linux发行版系统有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等    </p><p>kali linux：安全渗透,逆向</p><p>本篇笔记是基于<strong>CentOS 7</strong> 写的，其他linux发行版命令略有不同，但大同小异</p></blockquote><p><img src="https://s3.ax1x.com/2020/12/02/D5JsRx.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/02/D5JsRx.jpg" srcset="data:image/png;base64,666"></p><h3 id="Linux-应用领域"><a href="#Linux-应用领域" class="headerlink" title="Linux 应用领域"></a>Linux 应用领域</h3><p>今天各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 <strong>LAMP（Linux + Apache + MySQL + PHP）</strong>或 <strong>LNMP（Linux + Nginx+ MySQL + PHP）</strong>组合。</p><p>目前 Linux 不仅在家庭与企业中使用，并且在政府中也很受欢迎。</p><ul><li>巴西联邦政府由于支持 Linux 而世界闻名。</li><li>有新闻报道俄罗斯军队自己制造的 Linux 发布版的，做为 G.H.ost 项目已经取得成果。</li><li>印度的 Kerala 联邦计划在向全联邦的高中推广使用 Linux。</li><li>中华人民共和国为取得技术独立，在龙芯处理器中排他性地使用 Linux。</li><li>在西班牙的一些地区开发了自己的 Linux 发布版，并且在政府与教育领域广泛使用，如 Extremadura 地区的 gnuLinEx 和 Andalusia 地区的 Guadalinex。</li><li>葡萄牙同样使用自己的 Linux 发布版 Caixa Mágica，用于 Magalh?es 笔记本电脑和 e-escola 政府软件。</li><li>法国和德国同样开始逐步采用 Linux。</li></ul><h3 id="Linux-vs-Windows"><a href="#Linux-vs-Windows" class="headerlink" title="Linux vs Windows"></a>Linux vs Windows</h3><p><img src="https://s3.ax1x.com/2020/12/02/D5Jjoj.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/02/D5Jjoj.jpg" srcset="data:image/png;base64,666"></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="安装Linux操作系统"><a href="#安装Linux操作系统" class="headerlink" title="安装Linux操作系统"></a>安装Linux操作系统</h2><p>Linux 的安装，安装步骤比较繁琐，现在其实云服务器挺普遍的，价格也便宜，如果直接不想搭建，也可以直接买一台学习用用！</p><blockquote><p>本地物理机安装，不建议（如果不在意办公和娱乐性的话请忽略）</p></blockquote><blockquote><p>本地虚拟机安装，比较消耗电脑资源（不过服务器版本的linux也消耗不了多少资源）</p></blockquote><p>具体看 [这里]</p><blockquote><p>购买云服务器（不消耗本地资源，但耗money）</p></blockquote><p>虚拟机安装后占用空间，也会有些卡顿，我们作为程序员其实可以选择购买一台自己的服务器，这样的话更加接近真实线上工作；</p><p>1、阿里云购买服务器：<a href="https://www.aliyun.com/minisite/goods?userCode=0phtycgr">https://www.aliyun.com/minisite/goods?userCode=0phtycgr</a></p><p>2、购买完毕后，获取服务器的ip地址，重置服务器密码，就可以远程登录了</p><p>3、下载 XShell 工具，进行远程连接使用！连接成功效果如下：</p><p><strong>注意事项：</strong></p><p>如果要打开端口，需要在阿里云的安全组面板中开启对应的出入规则，不然的话会被阿里拦截！</p><blockquote><p>如果前期不好操作，可以推荐安装宝塔面板，傻瓜式管理服务器</p></blockquote><p>安装教程：<a href="https://www.bt.cn/bbs/thread-19376-1-1.html">https://www.bt.cn/bbs/thread-19376-1-1.html</a></p><p>1、开启对应的端口</p><p>2、一键安装</p><p>3、安装完毕后会得到远程面板的地址，账号，密码，就可以登录了</p><p>4、登录之后就可以可视化的安装环境和部署网站！</p><h1 id="走近Linux系统"><a href="#走近Linux系统" class="headerlink" title="走近Linux系统"></a>走近Linux系统</h1><blockquote><p>一些命令没有反馈，一般代表命令执行成功（没有消息就是修好的消息）</p></blockquote><h2 id="开-关机"><a href="#开-关机" class="headerlink" title="开\关机"></a>开\关机</h2><blockquote><p>开机登录</p></blockquote><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>开机成功后，它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份，密码是不显示的，输完回车即可！</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><blockquote><p>关机</p></blockquote><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>关机指令为：shutdown ；</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">sync # 将数据由内存同步到硬盘中。shutdown # 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：shutdown –h 10 # 这个命令告诉大家，计算机将在10分钟后关机shutdown –h now # 立马关机shutdown –h 20:25 # 系统会在今天20:25关机shutdown –h +10 # 十分钟后关机shutdown –r now # 系统立马重启shutdown –r +10 # 系统十分钟后重启reboot # 就是重启，等同于 shutdown –r nowhalt # 关闭系统，等同于shutdown –h now 和 poweroff<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><blockquote><p>系统目录结构</p></blockquote><p>登录系统后，在当前命令窗口下输入命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ls &#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你会看到如下图所示：</p><p><img src="https://s3.ax1x.com/2020/12/02/D5TUdU.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/02/D5TUdU.jpg" srcset="data:image/png;base64,666"><br>树状目录结构：（Linux的一切资源都挂载在这个 / 根节点下）</p><p><strong>以下是对这些目录的解释：</strong></p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。<ul><li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li></ul></li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim</title>
      <link href="2020/12/02/Linux/Vim/Vim/"/>
      <url>2020/12/02/Linux/Vim/Vim/</url>
      
        <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="vim快捷键-命令"><a href="#vim快捷键-命令" class="headerlink" title="vim快捷键(命令)"></a>vim快捷键(命令)</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul><li><strong>i</strong>   切换到输入模式，以输入字符</li><li><strong>:(shift+;)</strong>       切换到底线命令模式，以在最底一行输入命令</li><li><strong>dd</strong>     删除当前光标所处的行</li><li><strong>x</strong>        删除当前光标所在处的字符</li></ul><h3 id="插入模式-输入模式"><a href="#插入模式-输入模式" class="headerlink" title="插入模式(输入模式)"></a>插入模式(输入模式)</h3><ul><li><strong>字符按键以及Shift组合</strong>     输入字符</li><li><strong>ENTER</strong>     回车键，换行</li><li><strong>BACK SPACE</strong>     退格键，删除光标前一个字符</li><li><strong>DEL</strong>     删除键，删除光标后一个字符</li><li><strong>方向键</strong>     在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>      移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>    上/下翻页</li><li><strong>Insert</strong>     切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>     退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>命令后加   <strong>!</strong>   强制执行</p><ul><li><strong>version</strong>       查看版本信息 , 配置</li><li><strong>w</strong>      保存</li><li><strong>q</strong>       退出</li><li><strong>wq</strong>    保存并退出</li></ul><h3 id="vi-vim键盘图"><a href="#vi-vim键盘图" class="headerlink" title="vi/vim键盘图"></a>vi/vim键盘图</h3><p><img src="static%5Cimgs%5Cvim%5Cvi-vim-cheat-sheet-sch.gif" class="lazyload" data-srcset="static%5Cimgs%5Cvim%5Cvi-vim-cheat-sheet-sch.gif" srcset="data:image/png;base64,666" alt="img"></p><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><p>vim配置文件  ~/.vimrc</p><p>注释格式为 :  “ 注释内容</p><h3 id="vimrc可用参数"><a href="#vimrc可用参数" class="headerlink" title="vimrc可用参数:"></a>vimrc可用参数:</h3><h4 id="显示相关"><a href="#显示相关" class="headerlink" title="显示相关"></a>显示相关</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&quot;set shortmess&#x3D;atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示  &quot;winpos 5 5          &quot; 设定窗口位置  &quot;set lines&#x3D;40 columns&#x3D;155    &quot; 设定窗口大小  &quot;set nu              &quot; 显示行号  set go&#x3D;             &quot; 不要图形按钮  &quot;color asmanian2     &quot; 设置背景主题  set guifont&#x3D;Courier_New:h10:cANSI   &quot; 设置字体  &quot;syntax on           &quot; 语法高亮  autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行&quot;set ruler           &quot; 显示标尺  set showcmd         &quot; 输入的命令显示出来，看的清楚些  &quot;set cmdheight&#x3D;1     &quot; 命令行（在状态行下）的高度，设置为1  &quot;set whichwrap+&#x3D;&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  &quot;set scrolloff&#x3D;3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  set novisualbell    &quot; 不要闪烁(不明白)  set statusline&#x3D;%F%m%r%h%w\ [FORMAT&#x3D;%&#123;&amp;ff&#125;]\ [TYPE&#x3D;%Y]\ [POS&#x3D;%l,%v][%p%%]\ %&#123;strftime(\&quot;%d&#x2F;%m&#x2F;%y\ -\ %H:%M\&quot;)&#125;   &quot;状态行显示的内容set laststatus&#x3D;1    &quot; 启动显示状态行(1),总是显示状态行(2)  set foldenable      &quot; 允许折叠  set foldmethod&#x3D;manual   &quot; 手动折叠  &quot;set background&#x3D;dark &quot;背景使用黑色 set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  &quot; 显示中文帮助if version &gt;&#x3D; 603set helplang&#x3D;cnset encoding&#x3D;utf-8endif&quot; 设置配色方案&quot;colorscheme murphy&quot;字体 &quot;if (has(&quot;gui_running&quot;)) &quot;   set guifont&#x3D;Bitstream\ Vera\ Sans\ Mono\ 10 &quot;endif set fencs&#x3D;utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936set termencoding&#x3D;utf-8set encoding&#x3D;utf-8set fileencodings&#x3D;ucs-bom,utf-8,cp936set fileencoding&#x3D;utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新文件标题"><a href="#新文件标题" class="headerlink" title="新文件标题"></a>新文件标题</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle() &quot;如果文件类型为.sh文件 if &amp;filetype &#x3D;&#x3D; &#39;sh&#39; call setline(1,&quot;\#########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;\# Author: ma6174&quot;) call append(line(&quot;.&quot;)+2, &quot;\# mail: ma6174@163.com&quot;) call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;\#########################################################################&quot;) call append(line(&quot;.&quot;)+5, &quot;\#!&#x2F;bin&#x2F;bash&quot;) call append(line(&quot;.&quot;)+6, &quot;&quot;) else call setline(1, &quot;&#x2F;*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;    &gt; Author: ma6174&quot;) call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail: ma6174@163.com &quot;) call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot; ***********************************************************************&#x2F;&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;)endifif &amp;filetype &#x3D;&#x3D; &#39;cpp&#39;call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;)call append(line(&quot;.&quot;)+8, &quot;&quot;)endifif &amp;filetype &#x3D;&#x3D; &#39;c&#39;call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)call append(line(&quot;.&quot;)+7, &quot;&quot;)endif&quot;新建文件后，自动定位到文件末尾autocmd BufNewFile * normal Gendfunc <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="键盘命令"><a href="#键盘命令" class="headerlink" title="键盘命令"></a>键盘命令</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nmap &lt;leader&gt;w :w!&lt;cr&gt;nmap &lt;leader&gt;f :find&lt;cr&gt;&quot; 映射全选+复制 ctrl+amap &lt;C-A&gt; ggVGYmap! &lt;C-A&gt; &lt;Esc&gt;ggVGYmap &lt;F12&gt; gg&#x3D;G&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot; 去空行  nnoremap &lt;F2&gt; :g&#x2F;^\s*$&#x2F;d&lt;CR&gt; &quot; 比较文件  nnoremap &lt;C-F2&gt; :vert diffsplit &quot; 新建标签  map &lt;M-F2&gt; :tabnew&lt;CR&gt;  &quot;列出当前目录文件  map &lt;F3&gt; :tabnew .&lt;CR&gt;  &quot;打开树状文件目录  map &lt;C-F3&gt; \be  &quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc()exec &quot;w&quot;if &amp;filetype &#x3D;&#x3D; &#39;c&#39;exec &quot;!g++ % -o %&lt;&quot;exec &quot;! .&#x2F;%&lt;&quot;elseif &amp;filetype &#x3D;&#x3D; &#39;cpp&#39;exec &quot;!g++ % -o %&lt;&quot;exec &quot;! .&#x2F;%&lt;&quot;elseif &amp;filetype &#x3D;&#x3D; &#39;java&#39; exec &quot;!javac %&quot; exec &quot;!java %&lt;&quot;elseif &amp;filetype &#x3D;&#x3D; &#39;sh&#39;:!.&#x2F;%endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb()exec &quot;w&quot;exec &quot;!g++ % -g -o %&lt;&quot;exec &quot;!gdb .&#x2F;%&lt;&quot;endfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实用设置"><a href="#实用设置" class="headerlink" title="实用设置"></a>实用设置</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt&#x3D;preview,menu &quot;允许插件  filetype plugin on&quot;共享剪贴板  set clipboard+&#x3D;unnamed &quot;从不备份  set nobackup&quot;make 运行:set makeprg&#x3D;g++\ -Wall\ \ %&quot;自动保存set autowriteset ruler                   &quot; 打开状态栏标尺set cursorline              &quot; 突出显示当前行set magic                   &quot; 设置魔术set guioptions-&#x3D;T           &quot; 隐藏工具栏set guioptions-&#x3D;m           &quot; 隐藏菜单栏&quot;set statusline&#x3D;\ %&lt;%F[%1*%M%*%n%R%H]%&#x3D;\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l&#x2F;%L%)\&quot; 设置在状态行显示的信息set foldcolumn&#x3D;0set foldmethod&#x3D;indent set foldlevel&#x3D;3 set foldenable              &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax&#x3D;on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop&#x3D;4&quot; 统一缩进为4set softtabstop&#x3D;4set shiftwidth&#x3D;4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history&#x3D;1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc&#x3D;utf-8set fencs&#x3D;utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu&#x3D;zh_CN.UTF-8set helplang&#x3D;cn&quot; 我的状态行显示的内容（包括文件类型和解码）&quot;set statusline&#x3D;%F%m%r%h%w\ [FORMAT&#x3D;%&#123;&amp;ff&#125;]\ [TYPE&#x3D;%Y]\ [POS&#x3D;%l,%v][%p%%]\ %&#123;strftime(\&quot;%d&#x2F;%m&#x2F;%y\ -\ %H:%M\&quot;)&#125;&quot;set statusline&#x3D;[%F]%y%r%m%*%&#x3D;[Line:%l&#x2F;%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus&#x3D;2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight&#x3D;2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+&#x3D;!&quot; 带有如下符号的单词不要被换行分割set iskeyword+&#x3D;_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace&#x3D;0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace&#x3D;2&quot; 允许backspace和光标键跨越行边界set whichwrap+&#x3D;&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse&#x3D;aset selection&#x3D;exclusiveset selectmode&#x3D;mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report&#x3D;0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars&#x3D;vert:\ ,stl:\ ,stlnc:\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime&#x3D;1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff&#x3D;3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile *  setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;&#x3D;ClosePair(&#39;)&#39;)&lt;CR&gt;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O:inoremap &#125; &lt;c-r&gt;&#x3D;ClosePair(&#39;&#125;&#39;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;&#x3D;ClosePair(&#39;]&#39;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &#39; &#39;&#39;&lt;ESC&gt;ifunction! ClosePair(char)if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] &#x3D;&#x3D; a:charreturn &quot;\&lt;Right&gt;&quot;elsereturn a:charendifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt&#x3D;longest,menu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CTags的设定"><a href="#CTags的设定" class="headerlink" title="CTags的设定"></a>CTags的设定</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">let Tlist_Sort_Type &#x3D; &quot;name&quot;    &quot; 按照名称排序  let Tlist_Use_Right_Window &#x3D; 1  &quot; 在右侧显示窗口  let Tlist_Compart_Format &#x3D; 1    &quot; 压缩方式  let Tlist_Exist_OnlyWindow &#x3D; 1  &quot; 如果只有一个buffer，kill窗口也kill掉buffer  let Tlist_File_Fold_Auto_Close &#x3D; 0  &quot; 不要关闭其他文件的tags  let Tlist_Enable_Fold_Column &#x3D; 0    &quot; 不要显示折叠树  autocmd FileType java set tags+&#x3D;D:\tools\java\tags  &quot;autocmd FileType h,cpp,cc,c set tags+&#x3D;D:\tools\cpp\tags  &quot;let Tlist_Show_One_File&#x3D;1            &quot;不同时显示多个文件的tag，只显示当前文件的&quot;设置tags  set tags&#x3D;tags  &quot;set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;其他东东&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;默认打开Taglist let Tlist_Auto_Open&#x3D;1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd &#x3D; &#39;&#x2F;usr&#x2F;bin&#x2F;ctags&#39; let Tlist_Show_One_File &#x3D; 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_Exit_OnlyWindow &#x3D; 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window &#x3D; 1 &quot;在右侧窗口中显示taglist窗口&quot; minibufexpl插件的一般设置let g:miniBufExplMapWindowNavVim &#x3D; 1let g:miniBufExplMapWindowNavArrows &#x3D; 1let g:miniBufExplMapCTabSwitchBufs &#x3D; 1let g:miniBufExplModSelTarget &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo-Github搭建个人博客二：更改博客主题</title>
      <link href="2020/11/23/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%8C%EF%BC%9A%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"/>
      <url>2020/11/23/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%8C%EF%BC%9A%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文所有内容来自于<a href="https://blog.csdn.net/weixin_44855907/article/details/105376826">这里</a>， 略有修改</p></blockquote><p>上篇博客讲述了实现把博客推到Github Page，接下来这篇博客就来讲一下更改和优化主题。<br>我使用的是volantis 主题（ Volantis是xaoxuu博主开发的主题），不是官方主题。其实这个主题对我来说难度挺大的，主要是因为主题 作者（我）的参考文档不够（太）详细~~ (菜)。 可我就是谗它好看，没办法。部署博客到远端Github用了一天，优化主题却整了整整三天（手动狗头，太难了）。<br>如何选主题：<br>强烈建议初学者选主题前先查阅一下这一个主题的使用人数多不多，这样出了问题比较好解决。帮助文档够不够详尽，这样可以少踩点坑。一开始还是使用中规中矩的官方主题，魔改的那些除非你比较有精力那就可以尝试。有了感觉之后再去自定义修改，尝试其他一下风格的主题，毕竟上手之后切换主题是分分钟钟的事。可以先看一下：<a href="https://www.zhihu.com/question/24422335">知乎的这篇文章</a></p><h2 id="volantis主题更改"><a href="#volantis主题更改" class="headerlink" title="volantis主题更改"></a>volantis主题更改</h2><h3 id="1-下载与安装volantis主题"><a href="#1-下载与安装volantis主题" class="headerlink" title="1 下载与安装volantis主题"></a>1 下载与安装volantis主题</h3><p>本地环境：我博客文件路径是E:\hexo\blog</p><h4 id="1-1-将主题下载到themes目录下"><a href="#1-1-将主题下载到themes目录下" class="headerlink" title="1.1 将主题下载到themes目录下"></a>1.1 将主题下载到themes目录下</h4><p>进入你本地放博客文件目录 进入到themes目录下<br>右键git bash here执行命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis themes&#x2F;volantis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行成功后，themes目录下有volantis文件夹</p><p><img src="https://s3.ax1x.com/2020/11/23/DJGRjx.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/11/23/DJGRjx.jpg" srcset="data:image/png;base64,666"></p><h4 id="1-2-修改站点配置文件"><a href="#1-2-修改站点配置文件" class="headerlink" title="1.2 修改站点配置文件"></a>1.2 修改站点配置文件</h4><p>注意是站点的_config.yml文件不是主题的_config.yml<br>用vscode或notepad++打开_config.yml文件找到themes字段 将默认的lanscape修改为你的主题volantis<br>其实之所以有两个配置文件是有原因的，你想啊。站点（也就是你的博客）的_config.yml用于配置你整个博客，如果你想换个主题，那么只要在站点的_config.yml修改theme就可了，不用大动干戈。想实现主题的一些其他功能如评论系统只要在主题的配置文件_config.ym修改就可以了，由于每个主题都有一个配置我呢见，换主题时也不会互相影响。</p><h4 id="1-4-检查并安装依赖"><a href="#1-4-检查并安装依赖" class="headerlink" title="1.4 检查并安装依赖"></a>1.4 检查并安装依赖</h4><p>安装 Hexo 搜索的依赖包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i -S hexo-generator-search hexo-generator-json-content<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 stylus 渲染器：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i -S hexo-renderer-stylus<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4）将hexo默认主题更换为volantis</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo clean #清除之前部署hexo g #生成hexo s# 本地预览<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行完上面操作就可以到 本地4000端口进行博客预览，可以发现主题已变了。<br>准备工作做足了，下面正式进入主题设置。由于主题官网已经对主题的配置做了比较详尽的介绍，我这里就不赘诉了，主要讲一下我的一下理解，和操作的大概流程。<br>一开始我由于没有站点/主题/页面这些概念所以也是比较蒙蔽，无从下手。其实不用看太多的教程，把官方文档看明白意思了，基本的博客框架就搭起来了，后续高级功能再慢慢学习优秀博主的Github源码，最后再自定义。个人觉得这个写文档的人逻辑表述能力不太强、将东西老是乱串的，反正我这个小白级博主是自己摸索之后才逐渐明白官网这样一个教程设置的顺序的。配置文件也鲜有中文注释，英文居多，我觉得这可能是难倒大多数新手的一个原因，遇到英文，不懂就整句百度翻译。</p><p>所以想首先对官网进行一下说明和解读。<br>官网顶端导航栏的几个按钮<br>【开始】：是我们volatis主题的下载与安装。</p><p>【站点】：是对我们整个博客的一个设置，如链接标签页显示的图标、标题等，所以是在博客的_config.yml下配置的。详细配置可以看hexo官网的官方文档<a href="https://hexo.io/zh-cn/docs/%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82">https://hexo.io/zh-cn/docs/中的配置。</a></p><p>【主题】：是有关对我们当前选的这个主题volantis的一个修改配置。你想设置什么功能，如评论系统、搜索功能这些。可以根据自己的需要去配置，这是这篇博客的重点，但不会讲具体怎么操作，因为文档有教，而是讲一些注意事项和我踩到的一些坑。</p><p>这里对volantis文件夹下的子文件夹和文件做一些简单的介绍</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">_config.yml: 为对整个主题的配置文件layout： 为页面、卡片（widget）、图标等源码和资源source： 为样式、第三方插件等源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="一些实用功能"><a href="#一些实用功能" class="headerlink" title="一些实用功能"></a>一些实用功能</h2><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>gitalk：gitalk，需要依赖github，我试了一下没有成功，而且评论者还需要登录github才可以评论，不好用。因而我选择用valine，一步到位，可匿名评价 。配置详见：这篇博客</p><h3 id="去掉封面的搜索框"><a href="#去掉封面的搜索框" class="headerlink" title="去掉封面的搜索框"></a>去掉封面的搜索框</h3><p>打开layout/_cover/index.ejs 找到如下所示代码，将其注释（如果你决定以后也不会使用这个封面的搜索框了 去掉也可以）</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs"><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>search<span class="token punctuation">.</span>enable <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </span><span class="token delimiter punctuation">%></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>m_search<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchform<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form u-search-form<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>input u-search-input<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%-</span><span class="token language-javascript"> theme<span class="token punctuation">.</span>cover <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>cover<span class="token punctuation">.</span>search </span><span class="token delimiter punctuation">%></span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>icon fas fa-search fa-fw<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token punctuation">&#125;</span> </span><span class="token delimiter punctuation">%></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果：</p><p><img src="https://s3.ax1x.com/2020/11/23/DJJErV.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/11/23/DJJErV.jpg" srcset="data:image/png;base64,666"></p><h3 id="修改使手机端观看有外边距"><a href="#修改使手机端观看有外边距" class="headerlink" title="修改使手机端观看有外边距"></a>修改使手机端观看有外边距</h3><p>打开source/css/_layout/main.styl<br>找到 @media screen and (max-width:$device-tablet)这一行 做如下修改</p><p><img src="https://s3.ax1x.com/2020/11/23/DJJwRA.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/11/23/DJJwRA.jpg" srcset="data:image/png;base64,666"></p><h3 id="配置模板文件使用new命令-自动生成模板文件"><a href="#配置模板文件使用new命令-自动生成模板文件" class="headerlink" title="配置模板文件使用new命令 自动生成模板文件"></a>配置模板文件使用new命令 自动生成模板文件</h3><p>E:\hexo\blog\scaffolds<br>编辑post.md 没有则新建<br>加入如下代码</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token hr punctuation">---</span>title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; comments: true # 是否开启评论mathjax: false # 是否开启数学公式渲染toc: true # 是否启用目录top: false # 是否置顶<span class="token title important"><span class="token punctuation">#</span>若使用urlname作为永久链接则添加该项</span>urlname:categories: <span class="token list punctuation">-</span> [父类,子类]<span class="token list punctuation">-</span> 同级分类<span class="token title important">tags: [标签1,标签2]<span class="token punctuation">---</span></span><span class="token comment">&lt;!-- more --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1）明明加了标签却无法在文章头部显示出来<br>不是用如下hexo命令new出来的文章标签是无法无法正常显示，即使是复制黏贴了用上面命令生成的文章的fromt-matter，也是不能正常显示的，所以先用hexo命令新建文件，再用markdown编辑器打开编辑。</p><p>hexo new ‘文章标题’<br>1</p><p>2）引用本地图片无法显示<br>你引用自己的本地图片发布路径写的是本地的路径，服务器无法访问你的本地文件当然无法正常加载啦。解决方法是实用图床生成外链。见博客[]<br>如外链之后引用图片，博客浏览过大或过小，可以先调整好大小再上传，如我遇到的问题就是，没有去查看博客头像预定的大小是多少（可以看别的已经搭好的博主的头像的参数 使用F12审查元素）</p><p>未完待续……</p><p>参考文章：<br><a href="https://wa2000.cn/post/202003171229/">Volantis主题DIY笔记</a><br><a href="https://volantis.js.org/getting-started/">volantis官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> volantis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo Github搭建个人博客一：将博客推到Github Page</title>
      <link href="2020/11/06/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%EF%BC%9A%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%8E%A8%E5%88%B0Github-Page/"/>
      <url>2020/11/06/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%EF%BC%9A%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%8E%A8%E5%88%B0Github-Page/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文所有内容来自于<a href="https://blog.csdn.net/weixin_44855907/article/details/105312948">Johnny</a>, 略有修改</p></blockquote><h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h2><p>打开Hexo你会发现醒目的一行字：“Hexo is a fast, simple &amp; powerful blog framework”。其实说白了hexo就是个博客框架。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>安装好 Nodejs</p></li><li><p>安装好 Git</p></li><li><p>以及注册一个Github账号</p></li></ul><p>官网下载的Node.js安装包自带npm节点包管理工具，npm从其nmp官网下载对应的插件包到本地，因为该网站的服务器在国外，经常会出现下载缓慢或出现异常，这时便需要找到另外的方法提供稳定的下载。这个方法就是cnpm。阿里巴巴的淘宝团队把nmp官网的插件都同步到了在中国的服务器，提供给我们从这个服务器上稳定下载资源。简单来说就是为了防止因为下载速度过慢而导致失败，我们还要与预先处理一下。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>解决上述问题有如下两个方法，我选择的是方法一：</p><h4 id="方法一、通过npm下载cnpm"><a href="#方法一、通过npm下载cnpm" class="headerlink" title="方法一、通过npm下载cnpm"></a>方法一、通过npm下载cnpm</h4><p>命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org# 其中-g是全局的意思<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhP5ct"><img src="https://s1.ax1x.com/2020/11/06/BhP5ct.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhP5ct.jpg" srcset="data:image/png;base64,666" alt="BhP5ct.jpg"></a></p><p>检验cnpm有没有安装成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cnpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhilUe"><img src="https://s1.ax1x.com/2020/11/06/BhilUe.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhilUe.jpg" srcset="data:image/png;base64,666" alt="BhilUe.jpg"></a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#或者cnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="方法二、修改npm的默认镜像源"><a href="#方法二、修改npm的默认镜像源" class="headerlink" title="方法二、修改npm的默认镜像源"></a>方法二、修改npm的默认镜像源</h4><p>1）查询当前的npm的源，“<a href="http://registry.npmjs.org”为默认的官方源./">http://registry.npmjs.org”为默认的官方源。</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2） 设置npm的淘宝镜像源，“<a href="https://registry.npm.taobao.org”为淘宝的镜像源./">https://registry.npm.taobao.org”为淘宝的镜像源。</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org# 通过这条set命令就可以把npm的镜像源改为国内淘宝的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="正式安装hexo"><a href="#正式安装hexo" class="headerlink" title="正式安装hexo"></a>正式安装hexo</h3><p>由于我预处理是用的方法一 所以我用cnpm cnpm和npm是一样的 相当于双胞胎 用方法二的伙伴把cnpm改为npm就可以了 其他照旧</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhEbfe"><img src="https://s1.ax1x.com/2020/11/06/BhEbfe.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhEbfe.jpg" srcset="data:image/png;base64,666" alt="BhEbfe.jpg"></a><br>验证hexo是否安装成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhVEXn"><img src="https://s1.ax1x.com/2020/11/06/BhVEXn.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhVEXn.jpg" srcset="data:image/png;base64,666" alt="BhVEXn.jpg"></a><br>安装成功后进入对Hexo的初始配置</p><h2 id="Hexo初始配置"><a href="#Hexo初始配置" class="headerlink" title="Hexo初始配置"></a>Hexo初始配置</h2><ol><li>新建文件夹：我这里在E:/hexo下新建文件夹blog</li><li>cmd下进入blog所在目录下 hexo init 初始化文件夹blog</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhV6Bt"><img src="https://s1.ax1x.com/2020/11/06/BhV6Bt.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhV6Bt.jpg" srcset="data:image/png;base64,666" alt="BhV6Bt.jpg"></a></p><p>初始化成功后，得到如下文件</p><p><a href="https://imgchr.com/i/BhVLNT"><img src="https://s1.ax1x.com/2020/11/06/BhVLNT.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhVLNT.jpg" srcset="data:image/png;base64,666" alt="BhVLNT.jpg"></a></p><p>这里对各个文件夹进行一个简单的说明，毕竟后面有些会用到</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">- node_modules：是依赖包- public：存放的是生成的页面- scaffolds：命令生成文章等的模板- source：用命令创建的各种文章- themes：主题- _config.yml：整个博客的配置- db.json：source解析所得到的- package.json：项目所需模块项目的配置信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装deployer"><a href="#安装deployer" class="headerlink" title="安装deployer"></a>安装deployer</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#安装能够将hexo部署到git page的deployercnpm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhZRq1"><img src="https://s1.ax1x.com/2020/11/06/BhZRq1.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhZRq1.jpg" srcset="data:image/png;base64,666" alt="BhZRq1.jpg"></a></p><h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">常见hexo命令1）generatehexo generate功能：生成静态文件。参数描述-d, --deploy 文件生成后立即部署网站-w, --watch 监视文件变动2）deployhexo deploy功能：部署网站。参数描述-g, --generate 部署网站前，需要预先生成静态文件3)serverhexo server功能：启动服务器。参数描述-p, --port 重设端口-s, --static 只使用静态文件-l, --log 启动日记记录，或覆盖记录格式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#hexo默认会有个Hello-World的博客文件hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhZvIf"><img src="https://s1.ax1x.com/2020/11/06/BhZvIf.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhZvIf.jpg" srcset="data:image/png;base64,666" alt="BhZvIf.jpg"></a></p><p>地址栏 输入：<a href="http://localhost:400就可以在本地看到Hello">http://localhost:400就可以在本地看到Hello</a> Word文章</p><p><a href="https://imgchr.com/i/BhePMj"><img src="https://s1.ax1x.com/2020/11/06/BhePMj.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhePMj.jpg" srcset="data:image/png;base64,666" alt="BhePMj.jpg"></a></p><p>上面只是在本地发布成功，要想让更多人看到，需要发布到远程服务器，这里部署到GitHUb</p><h2 id="部署博客到Github"><a href="#部署博客到Github" class="headerlink" title="部署博客到Github"></a>部署博客到Github</h2><p>1）首先自己创建一个Github账户。<br>2）创建一个仓库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">命名规范: 用户名.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 3）配置SSH密钥<br>只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">在E:\hexo\blog目录下右键 bash here进入git窗口ssh-keygen -t -C &quot;你GitHub的邮箱&quot;两次密码直接回车clip &lt;~&#x2F;ssh&#x2F;id_sra.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BheDeI"><img src="https://s1.ax1x.com/2020/11/06/BheDeI.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BheDeI.jpg" srcset="data:image/png;base64,666" alt="BheDeI.jpg"></a></p><p><a href="https://imgchr.com/i/BhecY8"><img src="https://s1.ax1x.com/2020/11/06/BhecY8.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhecY8.jpg" srcset="data:image/png;base64,666" alt="BhecY8.jpg"></a></p><p>在GitHub个人账号中进入setting选择SSH and GPG keys添加从bash生成的密钥</p><p><a href="https://imgchr.com/i/Bhe5mn"><img src="https://s1.ax1x.com/2020/11/06/Bhe5mn.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhe5mn.jpg" srcset="data:image/png;base64,666" alt="Bhe5mn.jpg"></a></p><p><a href="https://imgchr.com/i/BheX6J"><img src="https://s1.ax1x.com/2020/11/06/BheX6J.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BheX6J.jpg" srcset="data:image/png;base64,666" alt="BheX6J.jpg"></a></p><p>测试<br>在E:\hexo\blog目录下右键 bash here进入git窗口</p><p>输入如下命令</p><p><a href="https://imgchr.com/i/Bhm8Xj"><img src="https://s1.ax1x.com/2020/11/06/Bhm8Xj.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhm8Xj.jpg" srcset="data:image/png;base64,666" alt="Bhm8Xj.jpg"></a></p><p>提示如下</p><p><a href="https://imgchr.com/i/Bhmt7q"><img src="https://s1.ax1x.com/2020/11/06/Bhmt7q.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhmt7q.jpg" srcset="data:image/png;base64,666" alt="Bhmt7q.jpg"></a></p><p>输入yes后显示如下，则表示Github的SSH设置正确</p><p><a href="https://imgchr.com/i/Bhm6BR"><img src="https://s1.ax1x.com/2020/11/06/Bhm6BR.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhm6BR.jpg" srcset="data:image/png;base64,666" alt="Bhm6BR.jpg"></a></p><p>配置_config.yml</p><ol><li><p>获得SSH<br> <a href="https://imgchr.com/i/Bhmh9O"><img src="https://s1.ax1x.com/2020/11/06/Bhmh9O.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhmh9O.jpg" srcset="data:image/png;base64,666" alt="Bhmh9O.jpg"></a></p></li><li><p>配置_config.yml<br> 在E:/hexo/blog目录下找到_config.yml配置文件 用notepad++或者vscode打开修改<br> <a href="https://imgchr.com/i/BhnyRS"><img src="https://s1.ax1x.com/2020/11/06/BhnyRS.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhnyRS.jpg" srcset="data:image/png;base64,666" alt="BhnyRS.jpg"></a></p><p> 找到deploy结点，编辑如下：<br> repo为刚刚从GitHub复制来的SSH 粘贴即可<br> <a href="https://imgchr.com/i/Bhn2rj"><img src="https://s1.ax1x.com/2020/11/06/Bhn2rj.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhn2rj.jpg" srcset="data:image/png;base64,666" alt="Bhn2rj.jpg"></a></p></li></ol><h2 id="配置-Git-个人信息"><a href="#配置-Git-个人信息" class="headerlink" title="配置 Git 个人信息"></a>配置 Git 个人信息</h2><p>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致</p><p>cmd下使用下面两条命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global user.email &quot;邮箱&quot;git config --global user.name &quot;用户名&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到这里为止 git 操作实现本地代码库与 Github 代码库同步</p><h2 id="部署到远端Github"><a href="#部署到远端Github" class="headerlink" title="部署到远端Github"></a>部署到远端Github</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成静态网页并把它部署到远端<br><a href="https://imgchr.com/i/Bhnjd1"><img src="https://s1.ax1x.com/2020/11/06/Bhnjd1.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhnjd1.jpg" srcset="data:image/png;base64,666" alt="Bhnjd1.jpg"></a><br>输入：https://你的仓库名 就可以访问到了在这里插入图片描述<br>一切都布置好了，只差一杯咖啡，接下来就可以开工慢慢写文章啦<br>3、博客编写（简单一提）</p><p>我们会发现发布成功的博客文章放在_posts目录下<br>在这里插入图片描述<br>那么可以使用支持 .md编辑提供Markdown 语法编辑的的编辑器，然后保存文件到 …\source_posts 文件夹下即可，用CSDN自带的Markdown编辑器和小书匠都可以。这里用前者。</p><p>1）Markdown编辑器编辑博客，将生成的.md文件复制到 ..\source_posts<br>2）然后再hexo g -d 部署到远端GitHub就可以了</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>文章到这里就结束了，我自己搭建过程中还是有碰到不少坑的，所幸网上用Hexo搭建博客的人比较多，所以一搜基本上都有解决方案。所以也记录一下自己的搭建过程，也希望这篇文章能够帮助那些想用hexo搭建个人博客的小伙伴们少走点弯路。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> volantis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
