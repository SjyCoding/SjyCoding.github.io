<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker</title>
      <link href="2020/12/03/Docker/Docker/"/>
      <url>2020/12/03/Docker/Docker/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>原作者:  小陈    微信: chenxu521600</p><p>纯手打, 有修改</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><p><img src="Dovker.assets/image-20200903092232148.png" class="lazyload" data-srcset="Dovker.assets/image-20200903092232148.png" srcset="data:image/png;base64,666" alt="image-20200903092232148"></p><p>官网的介绍是” Docker is the world‘s leading software container platform “官方给docker的定位是一个应用容器平台.</p><h2 id="为什么是Docker"><a href="#为什么是Docker" class="headerlink" title="为什么是Docker"></a>为什么是Docker</h2><h2 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h2><p><img src="Docker.assets/image-20200903094505690.png" class="lazyload" data-srcset="Docker.assets/image-20200903094505690.png" srcset="data:image/png;base64,666" alt="image-20200903094505690"></p><h2 id="Docker的核心"><a href="#Docker的核心" class="headerlink" title="Docker的核心"></a>Docker的核心</h2><p><img src="Docker.assets/image-20200903151713477.png" class="lazyload" data-srcset="Docker.assets/image-20200903151713477.png" srcset="data:image/png;base64,666" alt="image-20200903151713477"></p><ul><li>镜像：一个镜像代表一个应用环境，它是一个只读的文件，如mysql镜像，tomcat镜像…</li><li>容器：镜像每次运行之后就是产生一个容器，就是正在运行的镜像，特点是可读可写</li><li>仓库：用来存放镜像的位置，蕾仕于maven仓库，也就是镜像下载和上传的位置</li><li>dockerfile：docker生成的镜像配置文件，用来书写自定义镜像的一些配置</li><li>tar：一个对镜像打包的文件，ihou还可以还原成镜像</li></ul>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="2020/12/03/Docker/Docker%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/03/Docker/Docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><blockquote><p>来源：维基百科，自由的百科全书</p></blockquote><table><thead><tr><th align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/250px-Docker_%28container_engine%29_logo.svg.png" class="lazyload" data-srcset="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4e/Docker_%28container_engine%29_logo.svg/250px-Docker_%28container_engine%29_logo.svg.png" srcset="data:image/png;base64,666"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1">原作者</a></td><td align="center">Solomon Hykes</td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E4%BB%B6%E9%96%8B%E7%99%BC">开发者</a></td><td align="center">Docker, Inc.</td></tr><tr><td align="center">初始版本</td><td align="center">2013年3月13日</td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E4%BB%93%E5%BA%93_(%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)">源代码库</a></td><td align="center"><a href="https://github.com/docker/docker-ce">github.com/docker/docker-ce</a><a href="https://www.wikidata.org/wiki/Q15206305#P1324"><img src=".static/Docker%E6%A6%82%E8%BF%B0-img/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png" class="lazyload" data-srcset=".static/Docker%E6%A6%82%E8%BF%B0-img/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png" srcset="data:image/png;base64,666" alt="编辑维基数据链接"></a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Go">Go</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/Linux">Linux</a>、<a href="https://zh.wikipedia.org/wiki/Windows">Windows</a>、<a href="https://zh.wikipedia.org/wiki/MacOS">macOS</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%B5%B1%E5%B9%B3%E5%8F%B0">系统平台</a></td><td align="center"><a href="https://zh.wikipedia.org/wiki/X86-64">x86-64</a>、<a href="https://zh.wikipedia.org/wiki/ARM%E6%9E%B6%E6%A7%8B">ARM</a>、s390x、<a href="https://zh.wikipedia.org/wiki/Ppc64">ppc64le</a></td></tr><tr><td align="center">类型</td><td align="center"><a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96">操作系统层虚拟化</a></td></tr><tr><td align="center"><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81">许可协议</a></td><td align="center"><strong>可执行档：</strong><a href="https://zh.wikipedia.org/wiki/%E5%85%8D%E8%B2%BB%E5%A2%9E%E5%80%BC">免费增值</a><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B3%E6%9C%8D%E5%8A%A1">软件即服务</a> <strong>源代码：</strong><a href="https://zh.wikipedia.org/wiki/Apache%E8%AE%B8%E5%8F%AF%E8%AF%81">Apache许可证</a> 2.0</td></tr><tr><td align="center">网站</td><td align="center"><a href="https://www.docker.com/">www.docker.com</a></td></tr></tbody></table><p><strong>Docker</strong> 是一个<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%8E%9F%E5%A7%8B%E7%A2%BC">开放源代码</a><a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94">软件</a>，是一个<a href="https://zh.wikipedia.org/wiki/%E9%96%8B%E6%94%BE%E5%B9%B3%E8%87%BA">开放平台</a>，用于开发应用、交付（shipping）应用、运行应用。 Docker允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件地速度。[<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-1">1]</a></p><p><strong>Docker容器</strong> 与虚拟机类似，但原理上，容器是将<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96">操作系统层虚拟化</a>，虚拟机则是虚拟化硬件，因此容器更具有便携性、高效地利用服务器。 容器更多的用于表示 软件的一个标准化单元。由于容器的标准化，因此它可以无视基础设施（Infrastructure）的差异，部署到任何一个地方。另外，Docker也为容器提供更强的业界的隔离兼容。[<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-2">2]</a></p><p><strong>Docker</strong> 利用<a href="https://zh.wikipedia.org/wiki/Linux%E6%A0%B8%E5%BF%83">Linux核心</a>中的资源分离机制，例如<a href="https://zh.wikipedia.org/wiki/Cgroups">cgroups</a>，以及Linux核心<a href="https://zh.wikipedia.org/w/index.php?title=Linux%E5%91%BD%E5%90%8D%E7%A9%BA%E9%96%93&action=edit&redlink=1">名字空间</a>（namespaces），来创建独立的<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96">容器</a>（containers）。这可以在单一Linux实体下运作，避免引导一个<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E6%A9%9F%E5%99%A8">虚拟机</a>造成的额外负担[<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-3">3]</a>。Linux核心对名字空间的支持完全隔离了工作环境中应用程序的视野，包括行程树、<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">网络</a>、用户ID与挂载文件系统，而核心的cgroup提供资源隔离，包括<a href="https://zh.wikipedia.org/wiki/CPU">CPU</a>、<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E8%A8%98%E6%86%B6%E9%AB%94">存储器</a>、block I/O与网络。从0.9版本起，Dockers在使用抽象虚拟是经由<a href="https://zh.wikipedia.org/wiki/Libvirt">libvirt</a>的<a href="https://zh.wikipedia.org/wiki/LXC">LXC</a>与systemd - nspawn提供界面的基础上，开始包括libcontainer库做为以自己的方式开始直接使用由Linux核心提供的虚拟化的设施，</p><p>依据行业分析公司“451研究”：“Dockers是有能力打包应用程序及其虚拟容器，可以在任何Linux服务器上运行的依赖性工具，这有助于实现灵活性和便携性，应用程序在任何地方都可以运行，无论是<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E7%94%A8%E9%9B%B2">公用云</a>、<a href="https://zh.wikipedia.org/wiki/%E7%A7%81%E6%9C%89%E9%9B%B2">私有云</a>、单机等。” [<a href="https://zh.wikipedia.org/wiki/Docker#cite_note-4">4]</a>。</p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><h2 id="通过安装脚本-推荐"><a href="#通过安装脚本-推荐" class="headerlink" title="通过安装脚本 - 推荐"></a>通过安装脚本 - 推荐</h2><ul><li><p>CentOS</p><p>  Docker 仅支持以下的 64 位 CentOS 版本：</p><ul><li><p>CentOS 7</p></li><li><p>CentOS 8</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 使用官方安装脚本安装curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun# 使用国内 daocloud 一键安装命令curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;docker | sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h2 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h2><p>TODO: 待更新</p><h2 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h2><blockquote><p>如果使用dockers的</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h1><h2 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a>辅助命令</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">docker --version# 版本信息&#x3D; docker -vdocker info# 详细信息docker --help# 帮助<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="images-镜像命令"><a href="#images-镜像命令" class="headerlink" title="images 镜像命令"></a>images 镜像命令</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 查看本机中所有镜像docker images# 列出本地所有镜像-a# 列出所有镜像(包含中间映像层)-q# 只显示镜像id# 搜索镜像docker search [options] 镜像名# 去dockerhub上查询镜像-s 指定值# 列出收场数不少于指定值的镜像--no-trunc  # 显示完整镜像信息# 从仓库下载镜像docker pull 镜像名[:TAG|@DIGEST]# 下载镜像# 删除镜像docker rmi 镜像名# 删除镜像-f# 强制删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Contrainer-容器命令"><a href="#Contrainer-容器命令" class="headerlink" title="Contrainer 容器命令"></a>Contrainer 容器命令</h2><h3 id="基本命令-容器外操作"><a href="#基本命令-容器外操作" class="headerlink" title="基本命令(容器外操作)"></a>基本命令(容器外操作)</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 运行容器docker run 镜像名# 镜像名新建并启动容器--name# 别名 为容器起一个名字-d# 启动守护式容器(在后台启动容器)-p# 映射端口号:原始端口号例:# 查看运行的容器docker ps# 列出所有正在运行的容器-a# 正在运行的和历史运行过的容器-q# 静默模式, 只显示容器id# 停止|关闭|重启容器docker start 容器名或id# 开启容器docker restart 容器名或id# 重启容器docker stop 容器名或id# 停止容器docker kill 容器名或id# 关闭容器# 删除容器docker rm -f 容器名或id例docker rm -f $(docker ps -aq)# 删除所有容器# 查看容器内进程docker top 容器名或id# 查看容器内进程# 产看容器内部细节docker inspect 容器id# 产看容器内部细节# 查看容器的运行日志docker logs [options] 容器名或id# 查看容器的运行日志-t# 加入时间戳-f# 跟随最新的日志打印<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="进阶命令-容器内操作"><a href="#进阶命令-容器内操作" class="headerlink" title="进阶命令(容器内操作)"></a>进阶命令(容器内操作)</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 进入容器内部docker exec [options] 容器id 容器内命令# 进入容器内执行命令-i# 以交互模式运行容器,通常与-t一起使用-t# 分配一个伪终端# 容器内安装软件apt-get updateapt-get install 安装包名称# 修改容器内文件# 退出容器exit# 退出容器# 将容器打包为性的镜像docker commit -a&#x3D;&quot;作者&quot; -m&#x3D;&quot;描述信息&quot; 容器id 目标镜像名称:TAG# 从容器中复制文件到宿主机目录中 docker cp 容器id:容器内资源路径 宿主机目录路径# 将容器内资源拷贝到宿主机上# 容器目录与宿主机目录同步 (数据卷 必须在运行容器时进行设置)docker run -it -v &#x2F;宿主机目录:&#x2F;容器目录:ro(只读) 镜像名注: 宿主机目录必须是绝对目录,宿主机目录会覆盖容器目录内容    运行 docker inspect 容器id 检查json串里有没有如下内容, 有则证明挂载成功    &quot;Mounts&quot;:&#123;    &#123;    &quot;Type&quot;:&quot;bind&quot;,    &quot;source&quot;:&quot;宿主机目录&quot;,    &quot;Destination&quot;:&quot;容器目录&quot;,    &quot;Mode&quot;:&quot;&quot;,    &quot;RW&quot;:true,    &quot;Propagation&quot;:&quot;rprivate&quot;,    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Docker-file"><a href="#Docker-file" class="headerlink" title="Docker file"></a>Docker file</h1><blockquote><p>​    DockerFile可以认为是**Docker镜像的描述文件, 是由一系列的命令和参数构成的 ‘脚本’ **</p><p>​    主要作用是<strong>用来构建docker镜像的构建文件</strong></p></blockquote><p><img src="https://s3.ax1x.com/2020/12/03/DoxWHH.png" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/03/DoxWHH.png" srcset="data:image/png;base64,666"></p><h2 id="Dockerfile解析过程"><a href="#Dockerfile解析过程" class="headerlink" title="Dockerfile解析过程"></a>Dockerfile解析过程</h2><p><img src="https://s3.ax1x.com/2020/12/03/DozFrF.png" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/03/DozFrF.png" srcset="data:image/png;base64,666"></p><h2 id="Dockerfile保留命令"><a href="#Dockerfile保留命令" class="headerlink" title="Dockerfile保留命令"></a>Dockerfile保留命令</h2><table><thead><tr><th>保留字</th><th align="center">作用</th></tr></thead><tbody><tr><td><strong>FROM</strong></td><td align="center">当前镜像是基于哪个镜像的, 第一个指令必须是FROM</td></tr><tr><td><strong>RUN</strong></td><td align="center"><strong>构建镜像时需要运行的命令</strong></td></tr><tr><td><strong>MAINTAINER</strong></td><td align="center">镜像维护者的姓名和邮箱地址 (官方不再推荐使用 废弃)</td></tr><tr><td><strong>WORKDIR</strong></td><td align="center">指定咋创建容器后, 终端默认登录进来的工作目录, 一个落脚点</td></tr><tr><td><strong>ENV</strong></td><td align="center">用来在构建容器过程中设置环境变量</td></tr><tr><td><strong>ADD</strong></td><td align="center">将宿主机目录下的文件拷贝进镜像  且ADD命令会自动处理URL和解压tar包</td></tr><tr><td><strong>COPY</strong></td><td align="center">类似ADD  拷贝文件和目录到镜像中<br/>将从构建上下文目录中&lt;原路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</td></tr><tr><td><strong>VOLUME</strong></td><td align="center">容器数据卷  用于数据保存和持久化操作</td></tr><tr><td><strong>CMD</strong></td><td align="center">指定一个容器启动时要运行的命令<br/>Dockerfile中可以有多个CMD命令, 但只有最后一个生效, CMD会被docker run之后的参数替换</td></tr><tr><td><strong>ENTRYPOINT</strong></td><td align="center">指定一个容器启动时要运行的命令<br/>ENTRYPOINT的目的和CMD一样, 都是在指定容器启动程序及其参数</td></tr></tbody></table><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><blockquote><p>​    基于哪个镜像构建新的镜像, 在构建时会从dockerhub拉取base镜像, 必须作为Dockerfile的第一个指令出现</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搜索超时</title>
      <link href="2020/12/02/Git&amp;GitHub/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Github%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
      <url>2020/12/02/Git&amp;GitHub/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/Github%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近几天的GitHub提交出了些问题，导致之前提交的更新丢失，考虑回退到之前的版本。在GitHub的Web页面上并没有找到回退的解决方案（如果大家知道的话，感谢告知），于是决定通过本地的 Git Bash来操作。</p><ul><li><p><strong>查找 commit id：</strong>浏览GitHub上的提交历史记录，找到要回退的版本，复制commit id。</p><p>  类似这种</p><p>  <img src="https://s3.ax1x.com/2020/12/02/DI4MQ0.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/12/02/DI4MQ0.jpg" srcset="data:image/png;base64,666" alt="这里写图片描述"></p></li></ul><ul><li><strong>恢复历史版本：</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">git reset --hard [你的commit id] <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>push：</strong>推送到GitHub远程仓库</li></ul><pre class="line-numbers language-none"><code class="language-none">git push -f -u origin master <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搜索超时</title>
      <link href="2020/12/02/Linux/%E9%97%AE%E9%A2%98/Docker%E6%90%9C%E7%B4%A2%E8%B6%85%E6%97%B6/"/>
      <url>2020/12/02/Linux/%E9%97%AE%E9%A2%98/Docker%E6%90%9C%E7%B4%A2%E8%B6%85%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker搜索超时"><a href="#Docker搜索超时" class="headerlink" title="Docker搜索超时"></a>Docker搜索超时</h2><p>执行<code>docker search centos</code>报错信息如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Error response from daemon: Get https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F;search?q&#x3D;centos: read tcp 52.200.132.201:443: i&#x2F;o timeout<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>docker在中国已经有了仓库：<a href="https://www.docker-cn.com/registry-mirror">https://www.docker-cn.com/registry-mirror</a></p><p>根据上面网站提供的修改方法。</p><p>进入<code>/etc/docker</code>目录下</p><p>查看有没有 daemon.json。这是docker默认的配置文件。</p><p>如果没有新建，如果有，则修改。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&#123;  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>保存退出。</p><p>重启docker服务：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">service docker restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> 镜像源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将linux的HOME目录下的文件夹名字改回英文的简单办法</title>
      <link href="2020/12/02/Linux/%E9%97%AE%E9%A2%98/%E5%B0%86linux%E7%9A%84%E7%94%A8%E6%88%B7%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/"/>
      <url>2020/12/02/Linux/%E9%97%AE%E9%A2%98/%E5%B0%86linux%E7%9A%84%E7%94%A8%E6%88%B7%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E5%A4%B9%E5%90%8D%E7%A7%B0%E6%94%B9%E6%88%90%E8%8B%B1%E6%96%87%E7%9A%84%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="将linux的HOME目录下的文件夹名字改回英文的简单办法"><a href="#将linux的HOME目录下的文件夹名字改回英文的简单办法" class="headerlink" title="将linux的HOME目录下的文件夹名字改回英文的简单办法"></a>将linux的HOME目录下的文件夹名字改回英文的简单办法</h2><p>为了使用起来方便，装了Ubuntu中文版，自然在home文件里用户目录的“桌面”、“图片”、“视频”、“音乐”……都是中文的。很多时候都喜欢在桌面上放一些要操作的文件，linux里命令行操作又多，难免会用命令行操作桌面上的东西，那么就要 “cd 桌面”，打“桌面”的时候要输入法切换，麻烦……</p><p>所以就想办法把用户目录下的路径改成英文，而其他的中文不变， 方法如下：</p><p>　　打开终端，在终端中输入命令:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export LANG&#x3D;en_US# 更改语言为英文xdg-user-dirs-gtk-update# 更新<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>跳出对话框询问是否将目录转化为英文路径,同意并关闭.</p><p>　　在终端中输入命令:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">export LANG&#x3D;zh_CN# 更改语言为中文<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        重启系统。或者再次运行　<code>xdg-user-dirs-gtk-update</code></p><p>系统会提示是否把转化好的目录改回中文，选择不再提示,并取消修改.主目录的中文转英文就完成了.</p><hr><p>在有些linux发行板中，上面的命令无法使用，不过我们可以动过手动修改的方式达到，具体方法路下：</p><p>​        找到～/.config/user-dirs.dis文件（注：~/代表当前用户目录  .config是个隐藏文件）<br>​        将该文件中的中文改成对应的英文<br>​        再在～/目录下创建对应的英文文件夹，重启就可以了</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 系统语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="2020/12/02/Git&amp;GitHub/git%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/02/Git&amp;GitHub/git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本片笔记基于B站up主<code>狂神说java</code>编写</p></blockquote><p>先了解下什么是版本控制</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p><ul><li>实现跨区域多人协同开发</li><li>追踪和记载一个或者多个文件的历史记录</li><li>组织和保护你的源代码和文档</li><li>统计工作量</li><li>并行开发、提高开发效率</li><li>跟踪记录整个软件的开发过程</li><li>减轻开发人员的负担，节省时间，同时降低人为错误</li></ul><p>简单说就是用于管理多人协同开发项目的技术。</p><p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p><p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0C4qeLxMgoTg9B154ibahsUaibiaV7DgH9GTFQZj3Kyhf5fxrj6G2U5HFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>多人开发就必须要使用版本控制！</p><h2 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h2><p>我们学习的东西，一定是当下最流行的！</p><p>主流的版本控制器有如下这些：</p><ul><li><strong>Git</strong></li><li><strong>SVN</strong>（Subversion）</li><li><strong>CVS</strong>（Concurrent Versions System）</li><li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li><li><strong>TFS</strong>（Team Foundation Server）</li><li>Visual Studio Online</li></ul><p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p><h2 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h2><p><strong>1、本地版本控制</strong></p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Dg3fHrbPqbNEOMO9GTjFhVaukMZWx54icS7eS2x8A7BEu0VB9ibwEhzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><strong>2、集中版本控制  SVN</strong></p><p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p00V4uLaibxtZI9RLpq7tkSdlWiaF92AVeZ0ib9DicqBkS2poo5u8sEU2mCQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p><p><strong>3、分布式版本控制     Git</strong></p><p>每个人都拥有全部的代码！安全隐患！</p><p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p><p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ev8Q7qXjsTfeSwFexdA4tGjFAiaVEKQzAHdGcINXILKflI2cfk9BiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><h2 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0qtEIDr2NG6rOGg1UgDu5c3ffRR8P7FD5D8BPLUEXp0hQoL7qfp3I6g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p>**<br>**</p><p>聊聊Git的历史</p><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p><p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p><p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p><p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p><p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p><p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0XGLbyFDUiccCsib4L9Vkg7neJVWupfScbrjd7zm7apC8eYTzgQztNAnA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p><p>Git环境配置</p><h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>打开 [git官网] <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p><p>所有东西下载慢的话就可以去找镜像！</p><p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0IXktseBR7lpvVF4bibFwiaibnGxkDm0wYicPIiaZxcUe2KuibAHj83MiaWFSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0IXktseBR7lpvVF4bibFwiaibnGxkDm0wYicPIiaZxcUe2KuibAHj83MiaWFSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>下载对应的版本即可安装！</p><p>安装：无脑下一步即可！安装完毕就可以使用了！</p><h2 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h2><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0jaiaAfr2pAfWtFX57kGYqR3SlNxDlAZDkCU6IOB1YAicKxHib5yGbv9zQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p><p><strong>Git CMD：</strong>Windows风格的命令行</p><p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p><h2 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h2><p>平时一定要多使用这些基础的命令！</p><p>1）、cd : 改变目录。</p><p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p><p>3）、pwd : 显示当前所在的目录路径。</p><p>4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p><p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p><p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p><p>7）、mkdir:  新建一个目录,就是新建一个文件夹。</p><p>8）、rm -r :  删除一个文件夹, rm -r src 删除src目录</p><pre class="line-numbers language-none"><code class="language-none">rm -rf &#x2F; 切勿在Linux中尝试！删除电脑中全部文件！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p><p>10）、reset 重新初始化终端/清屏。</p><p>11）、clear 清屏。</p><p>12）、history 查看命令历史。</p><p>13）、help 帮助。</p><p>14）、exit 退出。</p><p>15）、#表示注释</p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>所有的配置文件，其实都保存在本地！</p><p>查看配置 git config -l</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0GJANibs86DwYqoADdgZySGibmafR8p1XBq6ZG3t0J2wSg9icrIVVQo6dQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>查看不同级别的配置文件：</p><ul><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">#查看系统configgit config --system --list　　#查看当前用户（global）配置git config --global  --list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>Git相关的配置文件：</strong></p><p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p><p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0hcJS0rxj3qoCVvfDKh3WxwQJlSV3P15EIZuejraOwXLdic6NCB8X8oQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p><h2 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h2><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><ul><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">git config --global user.name &quot;kuangshen&quot;  #名称git config --global user.email 24736743@qq.com   #邮箱<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0zQZY37q1iaG0n7445X8YgPVvZH5AqyGvT4RgmoyIcZlJWiaLcxyDgSdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0zQZY37q1iaG0n7445X8YgPVvZH5AqyGvT4RgmoyIcZlJWiaLcxyDgSdQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Git基本理论（重要）</p><h2 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h2><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0NJ4L9OPI9ia1MmibpvDd6cSddBdvrlbdEtyEOrh4CKnWVibyfCHa3lzXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Workspace：工作区，就是你平时存放项目代码的地方</li><li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li><li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li><li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li></ul><p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0icz6X2aibIgUWzHxtwX8kicPCKpDrsiaPzZk04OlI2bzlydzicBuXTJvLEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0icz6X2aibIgUWzHxtwX8kicPCKpDrsiaPzZk04OlI2bzlydzicBuXTJvLEQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><ul><li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li><li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li><li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li><li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li><li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li><li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li></ul><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>git的工作流程一般是这样的：</p><p>１、在工作目录中添加、修改文件；</p><p>２、将需要进行版本管理的文件放入暂存区域；</p><p>３、将暂存区域的文件提交到git仓库。</p><p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p09iaOhl0dACfLrMwNbDzucGQ30s3HnsiaczfcR6dC9OehicuwibKuHjRlzg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>Git项目搭建</p><h2 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h2><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p><p>日常使用只要记住下图6个命令：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0AII6YVooUzibpibzJnoOHHXUsL3f9DqA4horUibfcpEZ88Oyf2gQQNR6w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p><p>1、创建全新的仓库，需要用GIT管理的项目的根目录执行：</p><ul><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 在当前目录新建一个Git代码库$ git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p><ul><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 克隆一个项目和它的整个代码历史(版本信息)$ git clone [url]  # https:&#x2F;&#x2F;gitee.com&#x2F;kuangstudy&#x2F;openclass.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2、去 gitee 或者 github 上克隆一个测试！</p><p>Git文件操作</p><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p><ul><li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</li><li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件</li><li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li><li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p>上面说文件有4种状态，通过如下命令可以查看到文件的状态：</p><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">#查看指定文件状态git status [filename]#查看所有文件状态git status# git add .                  添加所有文件到暂存区# git commit -m &quot;消息内容&quot;    提交暂存区中的内容到本地仓库 -m 提交信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p><ol><li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li><li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li><li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li></ol><ul><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none">#为注释*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt     #但lib.txt除外&#x2F;temp        #仅忽略项目根目录下的TODO文件,不包括其它目录tempbuild&#x2F;       #忽略build&#x2F;目录下的所有文件doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用码云</p><h2 id="github-是有墙的，比较慢，在国内的话，我们一般使用-gitee-，公司中有时候会搭建自己的gitlab服务器"><a href="#github-是有墙的，比较慢，在国内的话，我们一般使用-gitee-，公司中有时候会搭建自己的gitlab服务器" class="headerlink" title="github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器"></a>github 是有墙的，比较慢，在国内的话，我们一般使用 gitee ，公司中有时候会搭建自己的gitlab服务器</h2><p>这个其实可以作为大家未来找工作的一个重要信息！</p><p>1、注册登录码云，完善个人信息</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ebAqhteskG4GHwD01bX4lXYmxlmMGn8PRqn4aCXfaQdp3SnbBHdibtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0ebAqhteskG4GHwD01bX4lXYmxlmMGn8PRqn4aCXfaQdp3SnbBHdibtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>2、设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</p><ul><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 进入 C:\Users\Administrator\.ssh 目录# 生成公钥ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0YlK4ibQ0EMs3LmRmdiahpma8ssTQedkhyShNkibTyFBvaZWicicTfNicWQIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>3、将公钥信息public key 添加到码云账户中即可！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0I5Zicrm4PEbnox9L5wjCPtPybCyrKI1JOkRWCYIY5zsX4FvI77LXXmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0I5Zicrm4PEbnox9L5wjCPtPybCyrKI1JOkRWCYIY5zsX4FvI77LXXmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>4、使用码云创建一个自己的仓库！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0FSIwJb9g6Qbp99jY605xdPfh3N4l2rGpD44d6NCcdibankBUL60uODg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0FSIwJb9g6Qbp99jY605xdPfh3N4l2rGpD44d6NCcdibankBUL60uODg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>许可证：开源是否可以随意转载，开源但是不能商业使用，不能转载，…  限制！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0S96XfGogNWVqRAexeybT7DXdyQhfcYJ1oEAgaH1RibRU0WZE0eczdxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0S96XfGogNWVqRAexeybT7DXdyQhfcYJ1oEAgaH1RibRU0WZE0eczdxw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>克隆到本地！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0PyKfGFd8UHSGIRbVLkXH5icQsgxh6K2RPibYeUER54UzuNVAYsgxXcfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0PyKfGFd8UHSGIRbVLkXH5icQsgxh6K2RPibYeUER54UzuNVAYsgxXcfA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>IDEA中集成Git</p><p>1、新建项目，绑定git。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0D8LPGu2SNKXD01IMqDaSkBeP8ibtvnasBYiaReyuZWAl0EjEib8IYf7cQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0D8LPGu2SNKXD01IMqDaSkBeP8ibtvnasBYiaReyuZWAl0EjEib8IYf7cQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>注意观察idea中的变化</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Cs93BiaOia1Sdk8icdH7vQzPfzIjuoTNYquKzYtrEe5mklhg2b7KOYsow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Cs93BiaOia1Sdk8icdH7vQzPfzIjuoTNYquKzYtrEe5mklhg2b7KOYsow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>2、修改文件，使用IDEA操作git。</p><ul><li>添加到暂存区</li><li>commit 提交</li><li>push到远程仓库</li></ul><p>3、提交测试</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0tERIszdgLVlUWamyRapfN74aR8XeGFV2OYWiaeR9CkYlfoBefRh2AIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0tERIszdgLVlUWamyRapfN74aR8XeGFV2OYWiaeR9CkYlfoBefRh2AIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>这些都是单个人的操作！</p><p>学习的方式最重要！学会学习！我上课的更多时候都是在教大家去学习一种理念和思想（学习方式）</p><p>有道无术、术尚可求。有术无道、止于术！</p><p>真正的教学，授人以渔！</p><h2 id="说明：GIT分支"><a href="#说明：GIT分支" class="headerlink" title="说明：GIT分支"></a>说明：GIT分支</h2><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0BOGzaG4QTc4JXO0hSlwcNtujNzAvxeibSrajLYLCT6otNnHDV9xYWwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0BOGzaG4QTc4JXO0hSlwcNtujNzAvxeibSrajLYLCT6otNnHDV9xYWwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Ayn87woxfepOhSlUj4FQTFUsia4ic0j6aQy4Tz32PRuJ0HSVeGeUzURA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Ayn87woxfepOhSlUj4FQTFUsia4ic0j6aQy4Tz32PRuJ0HSVeGeUzURA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>git分支中常用指令：</p><ul><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li></ul><pre class="line-numbers language-none"><code class="language-none"># 列出所有本地分支git branch# 列出所有远程分支git branch -r# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 合并指定分支到当前分支$ git merge [branch]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote&#x2F;branch]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IDEA中操作</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0wHNIYeTHC8aHGASoDyZO64QicslqiaMb1OJ1Z1LPoic3LBGyDIYBa7XXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0wHNIYeTHC8aHGASoDyZO64QicslqiaMb1OJ1Z1LPoic3LBGyDIYBa7XXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,666" alt="img"></p><p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p><p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p>作业练习：找一个小伙伴，一起搭建一个远程仓库，来练习Git！</p><p>1、不要把Git想的很难，工作中多练习使用就自然而然的会了！</p><p>2、Git的学习也十分多，看完我的Git教程之后，可以多去思考，总结到自己博客！</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo子分类和父分类</title>
      <link href="2020/12/02/Hexo%E5%8D%9A%E5%AE%A2/Hexo%E5%AD%90%E5%88%86%E7%B1%BB%E5%92%8C%E7%88%B6%E5%88%86%E7%B1%BB/"/>
      <url>2020/12/02/Hexo%E5%8D%9A%E5%AE%A2/Hexo%E5%AD%90%E5%88%86%E7%B1%BB%E5%92%8C%E7%88%B6%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>随着博客量的增加，更细致的分类变得更有必要</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>格式</p>  <pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">categories:- Diary- Life<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  这种格式会使分类Life成为Diary的子分类，而不是并列分类</p></li><li><p>更复杂的格式</p>  <pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">categories:- [Diary, PlayStation]- [Diary, Games]- [Life]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim</title>
      <link href="2020/12/02/Linux/Vim/Vim/"/>
      <url>2020/12/02/Linux/Vim/Vim/</url>
      
        <content type="html"><![CDATA[<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><h2 id="vim快捷键-命令"><a href="#vim快捷键-命令" class="headerlink" title="vim快捷键(命令)"></a>vim快捷键(命令)</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul><li><strong>i</strong>   切换到输入模式，以输入字符</li><li><strong>:(shift+;)</strong>       切换到底线命令模式，以在最底一行输入命令</li><li><strong>dd</strong>     删除当前光标所处的行</li><li><strong>x</strong>        删除当前光标所在处的字符</li></ul><h3 id="插入模式-输入模式"><a href="#插入模式-输入模式" class="headerlink" title="插入模式(输入模式)"></a>插入模式(输入模式)</h3><ul><li><strong>字符按键以及Shift组合</strong>     输入字符</li><li><strong>ENTER</strong>     回车键，换行</li><li><strong>BACK SPACE</strong>     退格键，删除光标前一个字符</li><li><strong>DEL</strong>     删除键，删除光标后一个字符</li><li><strong>方向键</strong>     在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>      移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>    上/下翻页</li><li><strong>Insert</strong>     切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>     退出输入模式，切换到命令模式</li></ul><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><p>命令后加   <strong>!</strong>   强制执行</p><ul><li><strong>version</strong>       查看版本信息 , 配置</li><li><strong>w</strong>      保存</li><li><strong>q</strong>       退出</li><li><strong>wq</strong>    保存并退出</li></ul><h3 id="vi-vim键盘图"><a href="#vi-vim键盘图" class="headerlink" title="vi/vim键盘图"></a>vi/vim键盘图</h3><p><img src="static%5Cimgs%5Cvim%5Cvi-vim-cheat-sheet-sch.gif" class="lazyload" data-srcset="static%5Cimgs%5Cvim%5Cvi-vim-cheat-sheet-sch.gif" srcset="data:image/png;base64,666" alt="img"></p><h2 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h2><p>vim配置文件  ~/.vimrc</p><p>注释格式为 :  “ 注释内容</p><h3 id="vimrc可用参数"><a href="#vimrc可用参数" class="headerlink" title="vimrc可用参数:"></a>vimrc可用参数:</h3><h4 id="显示相关"><a href="#显示相关" class="headerlink" title="显示相关"></a>显示相关</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&quot;set shortmess&#x3D;atI   &quot; 启动的时候不显示那个援助乌干达儿童的提示  &quot;winpos 5 5          &quot; 设定窗口位置  &quot;set lines&#x3D;40 columns&#x3D;155    &quot; 设定窗口大小  &quot;set nu              &quot; 显示行号  set go&#x3D;             &quot; 不要图形按钮  &quot;color asmanian2     &quot; 设置背景主题  set guifont&#x3D;Courier_New:h10:cANSI   &quot; 设置字体  &quot;syntax on           &quot; 语法高亮  autocmd InsertLeave * se nocul  &quot; 用浅色高亮当前行  autocmd InsertEnter * se cul    &quot; 用浅色高亮当前行&quot;set ruler           &quot; 显示标尺  set showcmd         &quot; 输入的命令显示出来，看的清楚些  &quot;set cmdheight&#x3D;1     &quot; 命令行（在状态行下）的高度，设置为1  &quot;set whichwrap+&#x3D;&lt;,&gt;,h,l   &quot; 允许backspace和光标键跨越行边界(不建议)  &quot;set scrolloff&#x3D;3     &quot; 光标移动到buffer的顶部和底部时保持3行距离  set novisualbell    &quot; 不要闪烁(不明白)  set statusline&#x3D;%F%m%r%h%w\ [FORMAT&#x3D;%&#123;&amp;ff&#125;]\ [TYPE&#x3D;%Y]\ [POS&#x3D;%l,%v][%p%%]\ %&#123;strftime(\&quot;%d&#x2F;%m&#x2F;%y\ -\ %H:%M\&quot;)&#125;   &quot;状态行显示的内容set laststatus&#x3D;1    &quot; 启动显示状态行(1),总是显示状态行(2)  set foldenable      &quot; 允许折叠  set foldmethod&#x3D;manual   &quot; 手动折叠  &quot;set background&#x3D;dark &quot;背景使用黑色 set nocompatible  &quot;去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  &quot; 显示中文帮助if version &gt;&#x3D; 603set helplang&#x3D;cnset encoding&#x3D;utf-8endif&quot; 设置配色方案&quot;colorscheme murphy&quot;字体 &quot;if (has(&quot;gui_running&quot;)) &quot;   set guifont&#x3D;Bitstream\ Vera\ Sans\ Mono\ 10 &quot;endif set fencs&#x3D;utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936set termencoding&#x3D;utf-8set encoding&#x3D;utf-8set fileencodings&#x3D;ucs-bom,utf-8,cp936set fileencoding&#x3D;utf-8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="新文件标题"><a href="#新文件标题" class="headerlink" title="新文件标题"></a>新文件标题</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&quot;新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec &quot;:call SetTitle()&quot; &quot;&quot;定义函数SetTitle，自动插入文件头 func SetTitle() &quot;如果文件类型为.sh文件 if &amp;filetype &#x3D;&#x3D; &#39;sh&#39; call setline(1,&quot;\#########################################################################&quot;) call append(line(&quot;.&quot;), &quot;\# File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;\# Author: ma6174&quot;) call append(line(&quot;.&quot;)+2, &quot;\# mail: ma6174@163.com&quot;) call append(line(&quot;.&quot;)+3, &quot;\# Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot;\#########################################################################&quot;) call append(line(&quot;.&quot;)+5, &quot;\#!&#x2F;bin&#x2F;bash&quot;) call append(line(&quot;.&quot;)+6, &quot;&quot;) else call setline(1, &quot;&#x2F;*************************************************************************&quot;) call append(line(&quot;.&quot;), &quot;    &gt; File Name: &quot;.expand(&quot;%&quot;)) call append(line(&quot;.&quot;)+1, &quot;    &gt; Author: ma6174&quot;) call append(line(&quot;.&quot;)+2, &quot;    &gt; Mail: ma6174@163.com &quot;) call append(line(&quot;.&quot;)+3, &quot;    &gt; Created Time: &quot;.strftime(&quot;%c&quot;)) call append(line(&quot;.&quot;)+4, &quot; ***********************************************************************&#x2F;&quot;) call append(line(&quot;.&quot;)+5, &quot;&quot;)endifif &amp;filetype &#x3D;&#x3D; &#39;cpp&#39;call append(line(&quot;.&quot;)+6, &quot;#include&lt;iostream&gt;&quot;)call append(line(&quot;.&quot;)+7, &quot;using namespace std;&quot;)call append(line(&quot;.&quot;)+8, &quot;&quot;)endifif &amp;filetype &#x3D;&#x3D; &#39;c&#39;call append(line(&quot;.&quot;)+6, &quot;#include&lt;stdio.h&gt;&quot;)call append(line(&quot;.&quot;)+7, &quot;&quot;)endif&quot;新建文件后，自动定位到文件末尾autocmd BufNewFile * normal Gendfunc <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="键盘命令"><a href="#键盘命令" class="headerlink" title="键盘命令"></a>键盘命令</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">nmap &lt;leader&gt;w :w!&lt;cr&gt;nmap &lt;leader&gt;f :find&lt;cr&gt;&quot; 映射全选+复制 ctrl+amap &lt;C-A&gt; ggVGYmap! &lt;C-A&gt; &lt;Esc&gt;ggVGYmap &lt;F12&gt; gg&#x3D;G&quot; 选中状态下 Ctrl+c 复制vmap &lt;C-c&gt; &quot;+y&quot; 去空行  nnoremap &lt;F2&gt; :g&#x2F;^\s*$&#x2F;d&lt;CR&gt; &quot; 比较文件  nnoremap &lt;C-F2&gt; :vert diffsplit &quot; 新建标签  map &lt;M-F2&gt; :tabnew&lt;CR&gt;  &quot;列出当前目录文件  map &lt;F3&gt; :tabnew .&lt;CR&gt;  &quot;打开树状文件目录  map &lt;C-F3&gt; \be  &quot;C，C++ 按F5编译运行map &lt;F5&gt; :call CompileRunGcc()&lt;CR&gt;func! CompileRunGcc()exec &quot;w&quot;if &amp;filetype &#x3D;&#x3D; &#39;c&#39;exec &quot;!g++ % -o %&lt;&quot;exec &quot;! .&#x2F;%&lt;&quot;elseif &amp;filetype &#x3D;&#x3D; &#39;cpp&#39;exec &quot;!g++ % -o %&lt;&quot;exec &quot;! .&#x2F;%&lt;&quot;elseif &amp;filetype &#x3D;&#x3D; &#39;java&#39; exec &quot;!javac %&quot; exec &quot;!java %&lt;&quot;elseif &amp;filetype &#x3D;&#x3D; &#39;sh&#39;:!.&#x2F;%endifendfunc&quot;C,C++的调试map &lt;F8&gt; :call Rungdb()&lt;CR&gt;func! Rungdb()exec &quot;w&quot;exec &quot;!g++ % -g -o %&lt;&quot;exec &quot;!gdb .&#x2F;%&lt;&quot;endfunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="实用设置"><a href="#实用设置" class="headerlink" title="实用设置"></a>实用设置</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">&quot; 设置当文件被改动时自动载入set autoread&quot; quickfix模式autocmd FileType c,cpp map &lt;buffer&gt; &lt;leader&gt;&lt;space&gt; :w&lt;cr&gt;:make&lt;cr&gt;&quot;代码补全 set completeopt&#x3D;preview,menu &quot;允许插件  filetype plugin on&quot;共享剪贴板  set clipboard+&#x3D;unnamed &quot;从不备份  set nobackup&quot;make 运行:set makeprg&#x3D;g++\ -Wall\ \ %&quot;自动保存set autowriteset ruler                   &quot; 打开状态栏标尺set cursorline              &quot; 突出显示当前行set magic                   &quot; 设置魔术set guioptions-&#x3D;T           &quot; 隐藏工具栏set guioptions-&#x3D;m           &quot; 隐藏菜单栏&quot;set statusline&#x3D;\ %&lt;%F[%1*%M%*%n%R%H]%&#x3D;\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l&#x2F;%L%)\&quot; 设置在状态行显示的信息set foldcolumn&#x3D;0set foldmethod&#x3D;indent set foldlevel&#x3D;3 set foldenable              &quot; 开始折叠&quot; 不要使用vi的键盘模式，而是vim自己的set nocompatible&quot; 语法高亮set syntax&#x3D;on&quot; 去掉输入错误的提示声音set noeb&quot; 在处理未保存或只读文件的时候，弹出确认set confirm&quot; 自动缩进set autoindentset cindent&quot; Tab键的宽度set tabstop&#x3D;4&quot; 统一缩进为4set softtabstop&#x3D;4set shiftwidth&#x3D;4&quot; 不要用空格代替制表符set noexpandtab&quot; 在行和段开始处使用制表符set smarttab&quot; 显示行号set number&quot; 历史记录数set history&#x3D;1000&quot;禁止生成临时文件set nobackupset noswapfile&quot;搜索忽略大小写set ignorecase&quot;搜索逐字符高亮set hlsearchset incsearch&quot;行内替换set gdefault&quot;编码设置set enc&#x3D;utf-8set fencs&#x3D;utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936&quot;语言设置set langmenu&#x3D;zh_CN.UTF-8set helplang&#x3D;cn&quot; 我的状态行显示的内容（包括文件类型和解码）&quot;set statusline&#x3D;%F%m%r%h%w\ [FORMAT&#x3D;%&#123;&amp;ff&#125;]\ [TYPE&#x3D;%Y]\ [POS&#x3D;%l,%v][%p%%]\ %&#123;strftime(\&quot;%d&#x2F;%m&#x2F;%y\ -\ %H:%M\&quot;)&#125;&quot;set statusline&#x3D;[%F]%y%r%m%*%&#x3D;[Line:%l&#x2F;%L,Column:%c][%p%%]&quot; 总是显示状态行set laststatus&#x3D;2&quot; 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight&#x3D;2&quot; 侦测文件类型filetype on&quot; 载入文件类型插件filetype plugin on&quot; 为特定文件类型载入相关缩进文件filetype indent on&quot; 保存全局变量set viminfo+&#x3D;!&quot; 带有如下符号的单词不要被换行分割set iskeyword+&#x3D;_,$,@,%,#,-&quot; 字符间插入的像素行数目set linespace&#x3D;0&quot; 增强模式中的命令行自动完成操作set wildmenu&quot; 使回格键（backspace）正常处理indent, eol, start等set backspace&#x3D;2&quot; 允许backspace和光标键跨越行边界set whichwrap+&#x3D;&lt;,&gt;,h,l&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse&#x3D;aset selection&#x3D;exclusiveset selectmode&#x3D;mouse,key&quot; 通过使用: commands命令，告诉我们文件的哪一行被改变过set report&#x3D;0&quot; 在被分割的窗口间显示空白，便于阅读set fillchars&#x3D;vert:\ ,stl:\ ,stlnc:\&quot; 高亮显示匹配的括号set showmatch&quot; 匹配括号高亮的时间（单位是十分之一秒）set matchtime&#x3D;1&quot; 光标移动到buffer的顶部和底部时保持3行距离set scrolloff&#x3D;3&quot; 为C程序提供自动缩进set smartindent&quot; 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile *  setfiletype txt&quot;自动补全:inoremap ( ()&lt;ESC&gt;i:inoremap ) &lt;c-r&gt;&#x3D;ClosePair(&#39;)&#39;)&lt;CR&gt;:inoremap &#123; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O:inoremap &#125; &lt;c-r&gt;&#x3D;ClosePair(&#39;&#125;&#39;)&lt;CR&gt;:inoremap [ []&lt;ESC&gt;i:inoremap ] &lt;c-r&gt;&#x3D;ClosePair(&#39;]&#39;)&lt;CR&gt;:inoremap &quot; &quot;&quot;&lt;ESC&gt;i:inoremap &#39; &#39;&#39;&lt;ESC&gt;ifunction! ClosePair(char)if getline(&#39;.&#39;)[col(&#39;.&#39;) - 1] &#x3D;&#x3D; a:charreturn &quot;\&lt;Right&gt;&quot;elsereturn a:charendifendfunctionfiletype plugin indent on &quot;打开文件类型检测, 加了这句才可以用智能补全set completeopt&#x3D;longest,menu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="CTags的设定"><a href="#CTags的设定" class="headerlink" title="CTags的设定"></a>CTags的设定</h4><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">let Tlist_Sort_Type &#x3D; &quot;name&quot;    &quot; 按照名称排序  let Tlist_Use_Right_Window &#x3D; 1  &quot; 在右侧显示窗口  let Tlist_Compart_Format &#x3D; 1    &quot; 压缩方式  let Tlist_Exist_OnlyWindow &#x3D; 1  &quot; 如果只有一个buffer，kill窗口也kill掉buffer  let Tlist_File_Fold_Auto_Close &#x3D; 0  &quot; 不要关闭其他文件的tags  let Tlist_Enable_Fold_Column &#x3D; 0    &quot; 不要显示折叠树  autocmd FileType java set tags+&#x3D;D:\tools\java\tags  &quot;autocmd FileType h,cpp,cc,c set tags+&#x3D;D:\tools\cpp\tags  &quot;let Tlist_Show_One_File&#x3D;1            &quot;不同时显示多个文件的tag，只显示当前文件的&quot;设置tags  set tags&#x3D;tags  &quot;set autochdir &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;其他东东&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;默认打开Taglist let Tlist_Auto_Open&#x3D;1 &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; &quot; Tag list (ctags) &quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; let Tlist_Ctags_Cmd &#x3D; &#39;&#x2F;usr&#x2F;bin&#x2F;ctags&#39; let Tlist_Show_One_File &#x3D; 1 &quot;不同时显示多个文件的tag，只显示当前文件的 let Tlist_Exit_OnlyWindow &#x3D; 1 &quot;如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window &#x3D; 1 &quot;在右侧窗口中显示taglist窗口&quot; minibufexpl插件的一般设置let g:miniBufExplMapWindowNavVim &#x3D; 1let g:miniBufExplMapWindowNavArrows &#x3D; 1let g:miniBufExplMapCTabSwitchBufs &#x3D; 1let g:miniBufExplModSelTarget &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo-Github搭建个人博客二：更改博客主题</title>
      <link href="2020/11/23/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%8C%EF%BC%9A%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"/>
      <url>2020/11/23/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%8C%EF%BC%9A%E6%9B%B4%E6%94%B9%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文所有内容来自于<a href="https://blog.csdn.net/weixin_44855907/article/details/105376826">这里</a>， 略有修改</p></blockquote><p>上篇博客讲述了实现把博客推到Github Page，接下来这篇博客就来讲一下更改和优化主题。<br>我使用的是volantis 主题（ Volantis是xaoxuu博主开发的主题），不是官方主题。其实这个主题对我来说难度挺大的，主要是因为主题 作者（我）的参考文档不够（太）详细~~ (菜)。 可我就是谗它好看，没办法。部署博客到远端Github用了一天，优化主题却整了整整三天（手动狗头，太难了）。<br>如何选主题：<br>强烈建议初学者选主题前先查阅一下这一个主题的使用人数多不多，这样出了问题比较好解决。帮助文档够不够详尽，这样可以少踩点坑。一开始还是使用中规中矩的官方主题，魔改的那些除非你比较有精力那就可以尝试。有了感觉之后再去自定义修改，尝试其他一下风格的主题，毕竟上手之后切换主题是分分钟钟的事。可以先看一下：<a href="https://www.zhihu.com/question/24422335">知乎的这篇文章</a></p><h2 id="volantis主题更改"><a href="#volantis主题更改" class="headerlink" title="volantis主题更改"></a>volantis主题更改</h2><h3 id="1-下载与安装volantis主题"><a href="#1-下载与安装volantis主题" class="headerlink" title="1 下载与安装volantis主题"></a>1 下载与安装volantis主题</h3><p>本地环境：我博客文件路径是E:\hexo\blog</p><h4 id="1-1-将主题下载到themes目录下"><a href="#1-1-将主题下载到themes目录下" class="headerlink" title="1.1 将主题下载到themes目录下"></a>1.1 将主题下载到themes目录下</h4><p>进入你本地放博客文件目录 进入到themes目录下<br>右键git bash here执行命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis themes&#x2F;volantis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行成功后，themes目录下有volantis文件夹</p><p><img src="https://s3.ax1x.com/2020/11/23/DJGRjx.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/11/23/DJGRjx.jpg" srcset="data:image/png;base64,666"></p><h4 id="1-2-修改站点配置文件"><a href="#1-2-修改站点配置文件" class="headerlink" title="1.2 修改站点配置文件"></a>1.2 修改站点配置文件</h4><p>注意是站点的_config.yml文件不是主题的_config.yml<br>用vscode或notepad++打开_config.yml文件找到themes字段 将默认的lanscape修改为你的主题volantis<br>其实之所以有两个配置文件是有原因的，你想啊。站点（也就是你的博客）的_config.yml用于配置你整个博客，如果你想换个主题，那么只要在站点的_config.yml修改theme就可了，不用大动干戈。想实现主题的一些其他功能如评论系统只要在主题的配置文件_config.ym修改就可以了，由于每个主题都有一个配置我呢见，换主题时也不会互相影响。</p><h4 id="1-4-检查并安装依赖"><a href="#1-4-检查并安装依赖" class="headerlink" title="1.4 检查并安装依赖"></a>1.4 检查并安装依赖</h4><p>安装 Hexo 搜索的依赖包：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i -S hexo-generator-search hexo-generator-json-content<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装 stylus 渲染器：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm i -S hexo-renderer-stylus<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4）将hexo默认主题更换为volantis</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo clean #清除之前部署hexo g #生成hexo s# 本地预览<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行完上面操作就可以到 本地4000端口进行博客预览，可以发现主题已变了。<br>准备工作做足了，下面正式进入主题设置。由于主题官网已经对主题的配置做了比较详尽的介绍，我这里就不赘诉了，主要讲一下我的一下理解，和操作的大概流程。<br>一开始我由于没有站点/主题/页面这些概念所以也是比较蒙蔽，无从下手。其实不用看太多的教程，把官方文档看明白意思了，基本的博客框架就搭起来了，后续高级功能再慢慢学习优秀博主的Github源码，最后再自定义。个人觉得这个写文档的人逻辑表述能力不太强、将东西老是乱串的，反正我这个小白级博主是自己摸索之后才逐渐明白官网这样一个教程设置的顺序的。配置文件也鲜有中文注释，英文居多，我觉得这可能是难倒大多数新手的一个原因，遇到英文，不懂就整句百度翻译。</p><p>所以想首先对官网进行一下说明和解读。<br>官网顶端导航栏的几个按钮<br>【开始】：是我们volatis主题的下载与安装。</p><p>【站点】：是对我们整个博客的一个设置，如链接标签页显示的图标、标题等，所以是在博客的_config.yml下配置的。详细配置可以看hexo官网的官方文档<a href="https://hexo.io/zh-cn/docs/%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82">https://hexo.io/zh-cn/docs/中的配置。</a></p><p>【主题】：是有关对我们当前选的这个主题volantis的一个修改配置。你想设置什么功能，如评论系统、搜索功能这些。可以根据自己的需要去配置，这是这篇博客的重点，但不会讲具体怎么操作，因为文档有教，而是讲一些注意事项和我踩到的一些坑。</p><p>这里对volantis文件夹下的子文件夹和文件做一些简单的介绍</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">_config.yml: 为对整个主题的配置文件layout： 为页面、卡片（widget）、图标等源码和资源source： 为样式、第三方插件等源码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="一些实用功能"><a href="#一些实用功能" class="headerlink" title="一些实用功能"></a>一些实用功能</h2><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>gitalk：gitalk，需要依赖github，我试了一下没有成功，而且评论者还需要登录github才可以评论，不好用。因而我选择用valine，一步到位，可匿名评价 。配置详见：这篇博客</p><h3 id="去掉封面的搜索框"><a href="#去掉封面的搜索框" class="headerlink" title="去掉封面的搜索框"></a>去掉封面的搜索框</h3><p>打开layout/_cover/index.ejs 找到如下所示代码，将其注释（如果你决定以后也不会使用这个封面的搜索框了 去掉也可以）</p><pre class="line-numbers language-ejs" data-language="ejs"><code class="language-ejs"><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token keyword">if</span> <span class="token punctuation">(</span>theme<span class="token punctuation">.</span>search<span class="token punctuation">.</span>enable <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> </span><span class="token delimiter punctuation">%></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>m_search<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>searchform<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form u-search-form<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>input u-search-input<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%-</span><span class="token language-javascript"> theme<span class="token punctuation">.</span>cover <span class="token operator">&amp;&amp;</span> theme<span class="token punctuation">.</span>cover<span class="token punctuation">.</span>search </span><span class="token delimiter punctuation">%></span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>icon fas fa-search fa-fw<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token ejs language-ejs"><span class="token delimiter punctuation">&lt;%</span><span class="token language-javascript"> <span class="token punctuation">&#125;</span> </span><span class="token delimiter punctuation">%></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>效果：</p><p><img src="https://s3.ax1x.com/2020/11/23/DJJErV.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/11/23/DJJErV.jpg" srcset="data:image/png;base64,666"></p><h3 id="修改使手机端观看有外边距"><a href="#修改使手机端观看有外边距" class="headerlink" title="修改使手机端观看有外边距"></a>修改使手机端观看有外边距</h3><p>打开source/css/_layout/main.styl<br>找到 @media screen and (max-width:$device-tablet)这一行 做如下修改</p><p><img src="https://s3.ax1x.com/2020/11/23/DJJwRA.jpg" class="lazyload" data-srcset="https://s3.ax1x.com/2020/11/23/DJJwRA.jpg" srcset="data:image/png;base64,666"></p><h3 id="配置模板文件使用new命令-自动生成模板文件"><a href="#配置模板文件使用new命令-自动生成模板文件" class="headerlink" title="配置模板文件使用new命令 自动生成模板文件"></a>配置模板文件使用new命令 自动生成模板文件</h3><p>E:\hexo\blog\scaffolds<br>编辑post.md 没有则新建<br>加入如下代码</p><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token hr punctuation">---</span>title: &#123;&#123; title &#125;&#125; date: &#123;&#123; date &#125;&#125; comments: true # 是否开启评论mathjax: false # 是否开启数学公式渲染toc: true # 是否启用目录top: false # 是否置顶<span class="token title important"><span class="token punctuation">#</span>若使用urlname作为永久链接则添加该项</span>urlname:categories: <span class="token list punctuation">-</span> [父类,子类]<span class="token list punctuation">-</span> 同级分类<span class="token title important">tags: [标签1,标签2]<span class="token punctuation">---</span></span><span class="token comment">&lt;!-- more --></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><p>1）明明加了标签却无法在文章头部显示出来<br>不是用如下hexo命令new出来的文章标签是无法无法正常显示，即使是复制黏贴了用上面命令生成的文章的fromt-matter，也是不能正常显示的，所以先用hexo命令新建文件，再用markdown编辑器打开编辑。</p><p>hexo new ‘文章标题’<br>1</p><p>2）引用本地图片无法显示<br>你引用自己的本地图片发布路径写的是本地的路径，服务器无法访问你的本地文件当然无法正常加载啦。解决方法是实用图床生成外链。见博客[]<br>如外链之后引用图片，博客浏览过大或过小，可以先调整好大小再上传，如我遇到的问题就是，没有去查看博客头像预定的大小是多少（可以看别的已经搭好的博主的头像的参数 使用F12审查元素）</p><p>未完待续……</p><p>参考文章：<br><a href="https://wa2000.cn/post/202003171229/">Volantis主题DIY笔记</a><br><a href="https://volantis.js.org/getting-started/">volantis官网</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> volantis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo Github搭建个人博客一：将博客推到Github Page</title>
      <link href="2020/11/06/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%EF%BC%9A%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%8E%A8%E5%88%B0Github-Page/"/>
      <url>2020/11/06/Hexo%E5%8D%9A%E5%AE%A2/%E5%9F%BA%E4%BA%8EHexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%80%EF%BC%9A%E5%B0%86%E5%8D%9A%E5%AE%A2%E6%8E%A8%E5%88%B0Github-Page/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>本文所有内容来自于<a href="https://blog.csdn.net/weixin_44855907/article/details/105312948">Johnny</a>, 略有修改</p></blockquote><h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h2><p>打开Hexo你会发现醒目的一行字：“Hexo is a fast, simple &amp; powerful blog framework”。其实说白了hexo就是个博客框架。</p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li><p>安装好 Nodejs</p></li><li><p>安装好 Git</p></li><li><p>以及注册一个Github账号</p></li></ul><p>官网下载的Node.js安装包自带npm节点包管理工具，npm从其nmp官网下载对应的插件包到本地，因为该网站的服务器在国外，经常会出现下载缓慢或出现异常，这时便需要找到另外的方法提供稳定的下载。这个方法就是cnpm。阿里巴巴的淘宝团队把nmp官网的插件都同步到了在中国的服务器，提供给我们从这个服务器上稳定下载资源。简单来说就是为了防止因为下载速度过慢而导致失败，我们还要与预先处理一下。</p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>解决上述问题有如下两个方法，我选择的是方法一：</p><h4 id="方法一、通过npm下载cnpm"><a href="#方法一、通过npm下载cnpm" class="headerlink" title="方法一、通过npm下载cnpm"></a>方法一、通过npm下载cnpm</h4><p>命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org# 其中-g是全局的意思<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhP5ct"><img src="https://s1.ax1x.com/2020/11/06/BhP5ct.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhP5ct.jpg" srcset="data:image/png;base64,666" alt="BhP5ct.jpg"></a></p><p>检验cnpm有没有安装成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cnpm<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhilUe"><img src="https://s1.ax1x.com/2020/11/06/BhilUe.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhilUe.jpg" srcset="data:image/png;base64,666" alt="BhilUe.jpg"></a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#或者cnpm -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="方法二、修改npm的默认镜像源"><a href="#方法二、修改npm的默认镜像源" class="headerlink" title="方法二、修改npm的默认镜像源"></a>方法二、修改npm的默认镜像源</h4><p>1）查询当前的npm的源，“<a href="http://registry.npmjs.org”为默认的官方源./">http://registry.npmjs.org”为默认的官方源。</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>2） 设置npm的淘宝镜像源，“<a href="https://registry.npm.taobao.org”为淘宝的镜像源./">https://registry.npm.taobao.org”为淘宝的镜像源。</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org# 通过这条set命令就可以把npm的镜像源改为国内淘宝的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="正式安装hexo"><a href="#正式安装hexo" class="headerlink" title="正式安装hexo"></a>正式安装hexo</h3><p>由于我预处理是用的方法一 所以我用cnpm cnpm和npm是一样的 相当于双胞胎 用方法二的伙伴把cnpm改为npm就可以了 其他照旧</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">cnpm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhEbfe"><img src="https://s1.ax1x.com/2020/11/06/BhEbfe.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhEbfe.jpg" srcset="data:image/png;base64,666" alt="BhEbfe.jpg"></a><br>验证hexo是否安装成功</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhVEXn"><img src="https://s1.ax1x.com/2020/11/06/BhVEXn.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhVEXn.jpg" srcset="data:image/png;base64,666" alt="BhVEXn.jpg"></a><br>安装成功后进入对Hexo的初始配置</p><h2 id="Hexo初始配置"><a href="#Hexo初始配置" class="headerlink" title="Hexo初始配置"></a>Hexo初始配置</h2><ol><li>新建文件夹：我这里在E:/hexo下新建文件夹blog</li><li>cmd下进入blog所在目录下 hexo init 初始化文件夹blog</li></ol><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhV6Bt"><img src="https://s1.ax1x.com/2020/11/06/BhV6Bt.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhV6Bt.jpg" srcset="data:image/png;base64,666" alt="BhV6Bt.jpg"></a></p><p>初始化成功后，得到如下文件</p><p><a href="https://imgchr.com/i/BhVLNT"><img src="https://s1.ax1x.com/2020/11/06/BhVLNT.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhVLNT.jpg" srcset="data:image/png;base64,666" alt="BhVLNT.jpg"></a></p><p>这里对各个文件夹进行一个简单的说明，毕竟后面有些会用到</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">- node_modules：是依赖包- public：存放的是生成的页面- scaffolds：命令生成文章等的模板- source：用命令创建的各种文章- themes：主题- _config.yml：整个博客的配置- db.json：source解析所得到的- package.json：项目所需模块项目的配置信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="安装deployer"><a href="#安装deployer" class="headerlink" title="安装deployer"></a>安装deployer</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#安装能够将hexo部署到git page的deployercnpm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhZRq1"><img src="https://s1.ax1x.com/2020/11/06/BhZRq1.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhZRq1.jpg" srcset="data:image/png;base64,666" alt="BhZRq1.jpg"></a></p><h2 id="本地查看效果"><a href="#本地查看效果" class="headerlink" title="本地查看效果"></a>本地查看效果</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">常见hexo命令1）generatehexo generate功能：生成静态文件。参数描述-d, --deploy 文件生成后立即部署网站-w, --watch 监视文件变动2）deployhexo deploy功能：部署网站。参数描述-g, --generate 部署网站前，需要预先生成静态文件3)serverhexo server功能：启动服务器。参数描述-p, --port 重设端口-s, --static 只使用静态文件-l, --log 启动日记记录，或覆盖记录格式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#hexo默认会有个Hello-World的博客文件hexo ghexo s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BhZvIf"><img src="https://s1.ax1x.com/2020/11/06/BhZvIf.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhZvIf.jpg" srcset="data:image/png;base64,666" alt="BhZvIf.jpg"></a></p><p>地址栏 输入：<a href="http://localhost:400就可以在本地看到Hello">http://localhost:400就可以在本地看到Hello</a> Word文章</p><p><a href="https://imgchr.com/i/BhePMj"><img src="https://s1.ax1x.com/2020/11/06/BhePMj.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhePMj.jpg" srcset="data:image/png;base64,666" alt="BhePMj.jpg"></a></p><p>上面只是在本地发布成功，要想让更多人看到，需要发布到远程服务器，这里部署到GitHUb</p><h2 id="部署博客到Github"><a href="#部署博客到Github" class="headerlink" title="部署博客到Github"></a>部署博客到Github</h2><p>1）首先自己创建一个Github账户。<br>2）创建一个仓库</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">命名规范: 用户名.github.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 3）配置SSH密钥<br>只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">在E:\hexo\blog目录下右键 bash here进入git窗口ssh-keygen -t -C &quot;你GitHub的邮箱&quot;两次密码直接回车clip &lt;~&#x2F;ssh&#x2F;id_sra.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://imgchr.com/i/BheDeI"><img src="https://s1.ax1x.com/2020/11/06/BheDeI.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BheDeI.jpg" srcset="data:image/png;base64,666" alt="BheDeI.jpg"></a></p><p><a href="https://imgchr.com/i/BhecY8"><img src="https://s1.ax1x.com/2020/11/06/BhecY8.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhecY8.jpg" srcset="data:image/png;base64,666" alt="BhecY8.jpg"></a></p><p>在GitHub个人账号中进入setting选择SSH and GPG keys添加从bash生成的密钥</p><p><a href="https://imgchr.com/i/Bhe5mn"><img src="https://s1.ax1x.com/2020/11/06/Bhe5mn.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhe5mn.jpg" srcset="data:image/png;base64,666" alt="Bhe5mn.jpg"></a></p><p><a href="https://imgchr.com/i/BheX6J"><img src="https://s1.ax1x.com/2020/11/06/BheX6J.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BheX6J.jpg" srcset="data:image/png;base64,666" alt="BheX6J.jpg"></a></p><p>测试<br>在E:\hexo\blog目录下右键 bash here进入git窗口</p><p>输入如下命令</p><p><a href="https://imgchr.com/i/Bhm8Xj"><img src="https://s1.ax1x.com/2020/11/06/Bhm8Xj.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhm8Xj.jpg" srcset="data:image/png;base64,666" alt="Bhm8Xj.jpg"></a></p><p>提示如下</p><p><a href="https://imgchr.com/i/Bhmt7q"><img src="https://s1.ax1x.com/2020/11/06/Bhmt7q.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhmt7q.jpg" srcset="data:image/png;base64,666" alt="Bhmt7q.jpg"></a></p><p>输入yes后显示如下，则表示Github的SSH设置正确</p><p><a href="https://imgchr.com/i/Bhm6BR"><img src="https://s1.ax1x.com/2020/11/06/Bhm6BR.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhm6BR.jpg" srcset="data:image/png;base64,666" alt="Bhm6BR.jpg"></a></p><p>配置_config.yml</p><ol><li><p>获得SSH<br> <a href="https://imgchr.com/i/Bhmh9O"><img src="https://s1.ax1x.com/2020/11/06/Bhmh9O.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhmh9O.jpg" srcset="data:image/png;base64,666" alt="Bhmh9O.jpg"></a></p></li><li><p>配置_config.yml<br> 在E:/hexo/blog目录下找到_config.yml配置文件 用notepad++或者vscode打开修改<br> <a href="https://imgchr.com/i/BhnyRS"><img src="https://s1.ax1x.com/2020/11/06/BhnyRS.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/BhnyRS.jpg" srcset="data:image/png;base64,666" alt="BhnyRS.jpg"></a></p><p> 找到deploy结点，编辑如下：<br> repo为刚刚从GitHub复制来的SSH 粘贴即可<br> <a href="https://imgchr.com/i/Bhn2rj"><img src="https://s1.ax1x.com/2020/11/06/Bhn2rj.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhn2rj.jpg" srcset="data:image/png;base64,666" alt="Bhn2rj.jpg"></a></p></li></ol><h2 id="配置-Git-个人信息"><a href="#配置-Git-个人信息" class="headerlink" title="配置 Git 个人信息"></a>配置 Git 个人信息</h2><p>Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致</p><p>cmd下使用下面两条命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">git config --global user.email &quot;邮箱&quot;git config --global user.name &quot;用户名&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>到这里为止 git 操作实现本地代码库与 Github 代码库同步</p><h2 id="部署到远端Github"><a href="#部署到远端Github" class="headerlink" title="部署到远端Github"></a>部署到远端Github</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成静态网页并把它部署到远端<br><a href="https://imgchr.com/i/Bhnjd1"><img src="https://s1.ax1x.com/2020/11/06/Bhnjd1.jpg" class="lazyload" data-srcset="https://s1.ax1x.com/2020/11/06/Bhnjd1.jpg" srcset="data:image/png;base64,666" alt="Bhnjd1.jpg"></a><br>输入：https://你的仓库名 就可以访问到了在这里插入图片描述<br>一切都布置好了，只差一杯咖啡，接下来就可以开工慢慢写文章啦<br>3、博客编写（简单一提）</p><p>我们会发现发布成功的博客文章放在_posts目录下<br>在这里插入图片描述<br>那么可以使用支持 .md编辑提供Markdown 语法编辑的的编辑器，然后保存文件到 …\source_posts 文件夹下即可，用CSDN自带的Markdown编辑器和小书匠都可以。这里用前者。</p><p>1）Markdown编辑器编辑博客，将生成的.md文件复制到 ..\source_posts<br>2）然后再hexo g -d 部署到远端GitHub就可以了</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>文章到这里就结束了，我自己搭建过程中还是有碰到不少坑的，所幸网上用Hexo搭建博客的人比较多，所以一搜基本上都有解决方案。所以也记录一下自己的搭建过程，也希望这篇文章能够帮助那些想用hexo搭建个人博客的小伙伴们少走点弯路。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> volantis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
